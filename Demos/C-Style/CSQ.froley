[attributes]
structural

[whitespace]
SPACE ' '
TAB   '\t'
EOL   '\n'

[tokens]
IDENTIFIER identifier [content]
INTEGER    integer    [content]

[keywords]
KEYWORD_FOR      for
KEYWORD_IF       if
KEYWORD_ELSE     else   [structural]
KEYWORD_WHILE    while

[symbols]
SYMBOL_ASTERISK             *
SYMBOL_CARET                ^
SYMBOL_CLOSE_CURLY          }  [structural]
SYMBOL_CLOSE_PAREN          )  [structural]
SYMBOL_COMMA                ,
SYMBOL_EQUALS               =
SYMBOL_MINUS                -
SYMBOL_OPEN_CURLY           {
SYMBOL_OPEN_PAREN           (
SYMBOL_PLUS                 +
SYMBOL_SEMICOLON            ;
SYMBOL_SLASH                /

[tokenizer]
<<tokenize>>
which (input)
  discardAll [whitespace]
endWhich

<whitespace_consumed>
markSourcePosition
if (not hasAnother) halt

if (scanIdentifier)
  which (buffer)
    acceptAll [keywords]
    others: accept IDENTIFIER
  endWhich
endIf

which (input)
  acceptAll [symbols]
  case '#'
    # Single-line comment
    ch = read
    while (ch != '\n') ch = read
    discard
  others
    ch = peek
    if (ch is digit)
      scan_integer
      accept INTEGER
    endIf
endWhich

clear buffer
collect "Syntax error - unexpected '"
ch = peek
collect ch
collect "'."
error buffer

<scan_integer>
while (ch is digit or ch == '_')
  ch = read
  if (ch != '_') collect ch
  if (not hasAnother) return
  ch = peek
endWhile
return


[parser]
- element
  if (hasAnother and nextHasAttribute(structural)) syntaxError
  statements

- statements
  if (not hasAnother) syntaxError
  if (nextHasAttribute(structural)) return
  beginList
  while (hasAnother and not nextHasAttribute(structural))
    statement
  endWhile
  produceStatements

- statement
  on '{'
    statements
    mustConsume "}"
    return
  elseOn "if"
    mustConsume "("
    expression
    mustConsume ")"
    statement
    parse_else
    produce CmdIf(condition,body,else_body)
  elseOn "for"
    mustConsume "("
    command
    command
    expression_or_empty
    mustConsume ")"
    statement
    produce CmdFor(initializer,condition,termination_test,body)
  elseOn "while"
    mustConsume "("
    expression
    mustConsume ")"
    statement
    produce CmdWhile(condition,body)
  else
    command
  endOn

- command
  on ';' -> CmdEmpty
  expression
  mustConsume ';'

- parse_else
  on "else"
    statement
  else
    produceNull
  endOn

- expression_or_empty
  if (nextIs(')')) produce CmdEmpty
  expression

- expression

+ assign : RightAssociativeBinaryParseRule
  on "=" -> CmdAssign

+ add_subtract : BinaryParseRule
  on "+" -> CmdAdd
  on "-" -> CmdSubtract

+ multiply_divide : BinaryParseRule
  on "*" -> CmdMultiply
  on "/" -> CmdDivide

+ power : BinaryParseRule
  on "^" -> CmdPower

+ pre_unary : PreUnaryParseRule
  on "-" -> CmdNegate

+ term
  on IDENTIFIER -> CmdAccess( value=t.content:String )
  on INTEGER    -> CmdLiteralInt32( value=t.content:Int32 )
  on "("
    expression
    mustConsume ")"
    return
  endOn
  syntaxError

