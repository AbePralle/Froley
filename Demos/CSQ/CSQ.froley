[settings]
id_start    alpha '_'
id_continue alpha numeric '_'

[attributes]
structural

[whitespace]
SPACE ' '
TAB   '\t'
EOL   '\n'
CR    '\r'

[tokens]
IDENTIFIER identifier [content]
INTEGER    integer    [content]
BEGIN_END  begin_end  [content]

[keywords]
KEYWORD_FOR      for
KEYWORD_IF       if
KEYWORD_ELSE     else   [structural]
KEYWORD_WHILE    while

[symbols]
SYMBOL_ASTERISK             *
SYMBOL_CARET                ^
SYMBOL_CLOSE_CURLY          }  [structural]
SYMBOL_CLOSE_PAREN          )  [structural]
SYMBOL_COMMA                ,
SYMBOL_EQUALS               =
SYMBOL_EQ                   ==
SYMBOL_GE                   >=
SYMBOL_GT                   >
SYMBOL_LE                   <=
SYMBOL_LT                   <
SYMBOL_MINUS                -
SYMBOL_MINUS_MINUS          --
SYMBOL_NE                   !=
SYMBOL_OPEN_CURLY           {
SYMBOL_OPEN_PAREN           (
SYMBOL_PLUS                 +
SYMBOL_PLUS_PLUS            ++
SYMBOL_SEMICOLON            ;
SYMBOL_SLASH                /

SYMBOL_PLUS_EQUALS          +=
SYMBOL_MINUS_EQUALS         -=
SYMBOL_TIMES_EQUALS         *=
SYMBOL_DIVIDE_EQUALS        /=
SYMBOL_MOD_EQUALS           %=
SYMBOL_AND_EQUALS           &=
SYMBOL_OR_EQUALS            |=

[tokenizer]
<<tokenize>>
which (input)
  discardAny [whitespace]
endWhich

<whitespace_consumed>
markSourcePosition
if (not hasAnother) halt

if (scanIdentifier)
  which (buffer)
    produceAny [keywords]
    others: produce IDENTIFIER
  endWhich
endIf

which (input)
  produceAny [symbols]
  case "//"
    # Single-line comment
    ch = read
    while (ch != '\n') ch = read
    discard
  others
    ch = peek
    if (ch is digit)
      scan_integer
      produce INTEGER
    endIf
endWhich

syntaxError

<scan_integer>
while (ch is digit or ch == '_')
  ch = read
  if (ch != '_') collect ch
  if (not hasAnother) return
  ch = peek
endWhile
return


[parser]
- element
  if (hasAnother and nextHasAttribute(structural)) syntaxError
  statements

- statements
  if (not hasAnother) syntaxError
  beginList
  while (hasAnother and not nextHasAttribute(structural))
    statement
  endWhile
  createStatements
  return

- args
  beginList
  if (not nextHasAttribute(structural) and not nextIs(';'))
    var first = true
    while (first or consume(','))
      first = false
      expression
    endWhile
  endIf
  createList

- for_args
  beginList
  if (not nextHasAttribute(structural) and not nextIs(';'))
    expression
    if (nextIs("identifier")) var_declaration
    while (consume(','))
      expression
    endWhile
  endIf
  createList

- statement
  on '{'
    statements
    mustConsume "}"
    return
  elseOn "if"
    mustConsume "("
    expression
    mustConsume ")"
    statement
    parse_else
    create If(condition,body,else_body)
    return
  elseOn "for"
    mustConsume "("
    for_args
    mustConsume ";"
    args
    mustConsume ";"
    args
    mustConsume ")"
    statement
    create For(initializer,condition,modifier,body)
    return
  elseOn "while"
    mustConsume "("
    expression
    mustConsume ")"
    statement
    create While(condition,body)
    return
  else
    command
  endOn

- command
  on ';' beginList; createStatements; return
  expression
  on ';' return
  if (nextIs("identifier")) var_declaration
  mustConsume ';'

- var_declaration
  on "identifier"
    create Name(value=t.content:String)
    if (consume('=')) expression
    else              createNull
    create LocalDeclaration(type,name,initial_value)
  endOn

- parse_else
  on "else"
    statement
  else
    createNull
    return
  endOn

- expression

+ assign : RightAssociativeBinaryParseRule
  on "="  -> Assign
  on "+=" -> AddAndAssign
  on "-=" -> SubtractAndAssign
  on "*=" -> MultiplyAndAssign
  on "/=" -> DivideAndAssign
  on "%=" -> ModAndAssign
  on "&=" -> AndAndAssign
  on "|=" -> OrAndAssign

+ logical_xor  : BinaryParseRule

+ logical_or   : BinaryParseRule

+ logical_and  : BinaryParseRule

+ comparison : BinaryParseRule
  on "==" -> CompareEQ
  on "!=" -> CompareNE
  on "<"  -> CompareLT
  on ">"  -> CompareGT
  on "<=" -> CompareLE
  on ">=" -> CompareGE

+ bitwise_xor : BinaryParseRule

+ bitwise_or  : BinaryParseRule

+ bitwise_and : BinaryParseRule

+ bitwise_shift : BinaryParseRule

+ add_subtract : BinaryParseRule
  on "+" -> Add
  on "-" -> Subtract

+ multiply_divide : BinaryParseRule
  on "*" -> Multiply
  on "/" -> Divide

+ pre_unary : PreUnaryParseRule
  on "-"  -> Negate
  on "++" -> PreIncrement
  on "--" -> PreDecrement

+ post_unary : PostUnaryParseRule
  on "++" -> PostIncrement
  on "--" -> PostDecrement

+ access : BinaryParseRule

+ term
  on IDENTIFIER -> Access( value=t.content:String )
  on INTEGER    -> LiteralInt32( value=t.content:Int32 )
  on '(', expression, ')': return
  syntaxError

