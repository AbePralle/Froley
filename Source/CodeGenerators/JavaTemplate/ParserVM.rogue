augment JavaTemplate
  PROPERTIES
    parser_vm =
      @|<froley.package>
       |
       |import java.io.*;
       |import java.util.*;
       |
       |public class ParserVM
       |{
       |  // DEFINITIONS
       |  final static public int MIN_VERSION = 1;
       |
       |  // PROPERTIES
       |  public String   filepath;
       |  public int[]    code;
       |  public String[] strings;
       |  public Token[]  tokens;
       |
       |  public int                     firstMethodAddress;
       |  public HashMap<String,Integer> methodAddresses      = new HashMap<String,Integer>();
       |  public HashMap<Integer,String> methodNamesByAddress = new HashMap<Integer,String>();
       |
       |  public IntList callStack           = new IntList();
       |  public IntList methodStack         = new IntList();
       |  public IntList numberStack         = new IntList();
       |  public ArrayList<Token> tokenStack = new ArrayList<Token>();
       |  public IntList tokenStackFrames    = new IntList();
       |
       |  public ArrayList<String> varNames  = new ArrayList<String>();
       |  public IntList           varValues = new IntList();
       |  public IntList           varFrames = new IntList().add( 0 );
       |
       |  public ArrayList<ParsePosition> savedPositions = new ArrayList<ParsePosition>();
       |
       |  public ArrayList<Cmd>  cmdQueue    = new ArrayList<Cmd>();
       |  public CmdInitArgs     cmdArgs     = new CmdInitArgs();
       |  public ArrayList<Token> listStartT   = new ArrayList<Token>();
       |  public IntList          listStartPos = new IntList();
       |
       |  public int   position;
       |  public int   nextTokenType;
       |  public Token curToken;
       |
       |  public Tokenizer tokenizer = new Tokenizer();
       |
       |  public void load( String data )
       |  {
       |    load( new Base64IntXReader(data) );
       |  }
       |
       |  public void load( Base64IntXReader reader )
       |  {
       |    int version = reader.readInt32X();
       |    if (version < MIN_VERSION) throw new Error( "[INTERNAL] Unsupported parser version: " + version );
       |
       |    int n = reader.readInt32X();
       |    strings = new String[ n ];
       |    for (int i=0; i<n; ++i)
       |    {
       |      strings[i] = reader.readString();
       |    }
       |
       |    // Method names & addresses
       |    n = reader.readInt32X();
       |    for (int i=0; i<n; ++i)
       |    {
       |      String name = strings[ reader.readInt32X() ];
       |      int methodAddress = reader.readInt32X();
       |      methodAddresses.put( name, methodAddress );
       |      methodNamesByAddress.put( methodAddress, name );
       |      if (i == 0) firstMethodAddress = methodAddress;
       |    }
       |
       |    n = reader.readInt32X();
       |    code = new int[ n ];
       |    for (int i=0; i<n; ++i)
       |    {
       |      code[i] = reader.readInt32X();
       |    }
       |  }
       |
       |  public void open( String filepath, String content )
       |  {
       |    open( filepath, content, 1, 1 );
       |  }
       |
       |  public void open( String filepath, String content, int startLine, int startColumn )
       |  {
       |    tokenizer.open( filepath, content, startLine, startColumn );
       |    open( filepath, tokenizer.tokenize() );
       |  }
       |
       |  public void open( File file )
       |  {
       |    tokenizer.open( file );
       |    open( file.getPath(), tokenizer.tokenize() );
       |  }
       |
       |  public void open( String filepath, Token[] tokens )
       |  {
       |    reset();
       |    this.filepath = filepath;
       |    this.tokens = tokens;
       |    if (tokens.length > 0)
       |    {
       |      nextTokenType = tokens[0].type;
       |    }
       |    else
       |    {
       |      nextTokenType = -1;
       |    }
       |    position = 0;
       |  }
       |
       |  public Cmd parse( String ruleName )
       |  {
       |    Integer methodAddress = methodAddresses.get( ruleName );
       |    if (methodAddress == null) throw new Error( "[INTERNAL] No parse rule '" + ruleName + "' exists." );
       |    return parse( methodAddress );
       |  }
       |
       |  public void reset()
       |  {
       |    callStack.clear();
       |    methodStack.clear();
       |    tokenStack.clear();
       |    tokenStackFrames.clear();
       |    numberStack.clear();
       |    varNames.clear();
       |    varValues.clear();
       |    varFrames.clear().add(0);
       |    savedPositions.clear();
       |    listStartT.clear();
       |    listStartPos.clear();
       |    position = 0;
       |    curToken = null;
       |    nextTokenType = -1;
       |    tokenizer.reset();
       |  }
       |
       |  public void execute( int ip )
       |  {
       |    curToken = peek();
       |    methodStack.add( ip );
       |    for (;;)
       |    {
       |      int opcode = code[ ip++ ];
       |      // trace( ip-1, 0 );
       |      switch (opcode)
       |      {
       |        case ParserOpcode.SYNTAX_ERROR:
       |          throwSyntaxError();
       |        case ParserOpcode.SYNTAX_ERROR_STRING:
       |          throw peek().error( strings[code[ip]] );
       |        case ParserOpcode.RETURN:
       |        {
       |          if (callStack.count == 0)
       |          {
       |            methodStack.clear();
       |            return;
       |          }
       |          ip = callStack.removeLast();
       |          methodStack.removeLast();
       |          int tCount = tokenStackFrames.removeLast();
       |          while (tokenStack.size() > tCount) tokenStack.remove( tokenStack.size()-1 );
       |          curToken = tokenStack.remove( tokenStack.size() - 1 );
       |          int varCount = varFrames.removeLast();
       |          while (varNames.size() > varCount) varNames.remove( varNames.size()-1 );
       |          varValues.count = varCount;
       |          continue;
       |        }
       |        case ParserOpcode.CALL:
       |          callStack.add( ip+1 );
       |          tokenStack.add( curToken );
       |          tokenStackFrames.add( tokenStack.size() );
       |          curToken = peek();
       |          ip = code[ ip ];
       |          methodStack.add( ip );
       |          varFrames.add( varValues.count );
       |          continue;
       |        case ParserOpcode.JUMP:
       |          ip = code[ ip ];
       |          continue;
       |        case ParserOpcode.JUMP_IF_TRUE:
       |          if (numberStack.count>0 && 0!=numberStack.removeLast()) ip = code[ ip ];
       |          else                                                    ++ip;
       |          continue;
       |        case ParserOpcode.JUMP_IF_FALSE:
       |          if (numberStack.count>0 && 0==numberStack.removeLast()) ip = code[ ip ];
       |          else                                                    ++ip;
       |          continue;
       |        case ParserOpcode.ON_TOKEN_TYPE:
       |          if (code[ip] == nextTokenType)
       |          {
       |            ip += 2;
       |            tokenStack.add( curToken );
       |            curToken = read();
       |          }
       |          else
       |          {
       |            ip = code[ ip+1 ];
       |          }
       |          continue;
       |        case ParserOpcode.ON_PEEK_TOKEN_TYPE:
       |          if (code[ip] == nextTokenType)
       |          {
       |            ip += 2;
       |            tokenStack.add( curToken );
       |            curToken = peek();
       |          }
       |          else
       |          {
       |            ip = code[ ip+1 ];
       |          }
       |          continue;
       |        case ParserOpcode.POP_CUR_TOKEN:
       |          curToken = tokenStack.remove( tokenStack.size()-1 );
       |          continue;
       |        case ParserOpcode.HAS_ANOTHER:
       |          numberStack.add( (nextTokenType!=-1)?1:0 );
       |          continue;
       |        case ParserOpcode.NEXT_HAS_ATTRIBUTE:
       |          numberStack.add( (nextTokenType != -1 && (TokenType.attributes[nextTokenType] & code[ip]) != 0) ? 1 : 0 );
       |          ++ip;
       |          continue;
       |        case ParserOpcode.NEXT_IS_TYPE:
       |          numberStack.add( (nextTokenType == code[ip++]) ? 1 : 0 );
       |          continue;
       |        case ParserOpcode.NEXT_IS_STRING:
       |        {
       |          String content = peek().content;
       |          numberStack.add( (content != null && content.equals(strings[code[ip]])) ? 1 : 0 );
       |          ++ip;
       |          continue;
       |        }
       |        case ParserOpcode.BEGIN_LIST:
       |          listStartT.add( peek() );
       |          listStartPos.add( cmdQueue.size() );
       |          continue;
       |        case ParserOpcode.CREATE_CMD:
       |        {
       |          int cmdTypeIndex = code[ ip++ ];
       |          int argCount = code[ ip++ ];
       |          cmdArgs.clear();
       |          cmdArgs.t = curToken;
       |          if (argCount > 0)
       |          {
       |            int i1 = cmdQueue.size() - argCount;
       |            if (i1 < 0)
       |            {
       |              trace( ip-2, 0 );
       |              throw curToken.error( "[INTERNAL] Command queue too small for new cmd." );
       |            }
       |            for (int i=i1; i<cmdQueue.size(); ++i)
       |            {
       |              cmdArgs.add( cmdQueue.get(i) );
       |            }
       |            while (cmdQueue.size() > i1) cmdQueue.remove( cmdQueue.size() - 1 );
       |          }
       |          cmdQueue.add( CmdFactory.createCmd(cmdTypeIndex,curToken,cmdArgs) );
       |          continue;
       |        }
       |
       |        case ParserOpcode.CREATE_NULL_CMD:
       |          cmdQueue.add( null );
       |          continue;
       |
       |        case ParserOpcode.CREATE_LIST:
       |        {
       |          if (listStartT.isEmpty()) throw peek().error( "[INTERNAL] No prior beginList before calling createList/produceList." );
       |          Token t  = listStartT.remove( listStartT.size() - 1 );
       |          int   i1 = listStartPos.removeLast();
       |          cmdArgs.clear();
       |          cmdArgs.t = curToken;
       |          for (int i=i1; i<cmdQueue.size(); ++i)
       |          {
       |            cmdArgs.add( cmdQueue.get(i) );
       |          }
       |          while (cmdQueue.size() > i1) cmdQueue.remove( cmdQueue.size() - 1 );
       |          cmdQueue.add( new Cmd.CmdList(curToken,cmdArgs) );
       |          continue;
       |        }
       |
       |        case ParserOpcode.CREATE_STATEMENTS:
       |        {
       |          if (listStartT.isEmpty()) throw peek().error( "[INTERNAL] No prior beginList before calling createStatements/produceStatements." );
       |          Token t  = listStartT.remove( listStartT.size() - 1 );
       |          int   i1 = listStartPos.removeLast();
       |          cmdArgs.clear();
       |          cmdArgs.t = curToken;
       |          for (int i=i1; i<cmdQueue.size(); ++i)
       |          {
       |            cmdArgs.add( cmdQueue.get(i) );
       |          }
       |          while (cmdQueue.size() > i1) cmdQueue.remove( cmdQueue.size() - 1 );
       |          cmdQueue.add( new Cmd.Statements(curToken,cmdArgs) );
       |          continue;
       |        }
       |
       |        case ParserOpcode.SWAP:
       |        {
       |          int n = cmdQueue.size();
       |          if (n >= 2)
       |          {
       |            Cmd a = cmdQueue.get( n-2 );
       |            Cmd b = cmdQueue.get( n-1 );
       |            cmdQueue.set( n-2, b );
       |            cmdQueue.set( n-1, a );
       |          }
       |          continue;
       |        }
       |
       |        case ParserOpcode.CONSUME_EOLS:
       |          // Called to automatically consume EOL tokens that occur in the
       |          // midst of parsing a unary or binary operator, like "a+\nb".
       |          <handle_consume_eols>
       |          continue;
       |
       |        case ParserOpcode.CONSUME_TYPE:
       |          if (nextTokenType == code[ip++])
       |          {
       |            read();
       |            numberStack.add( 1 );
       |          }
       |          else
       |          {
       |            numberStack.add( 0 );
       |          }
       |          continue;
       |
       |        case ParserOpcode.CONSUME_STRING:
       |        {
       |          String content = peek().content;
       |          if (content != null && content.equals(strings[code[ip]]))
       |          {
       |            read();
       |            numberStack.add( 1 );
       |          }
       |          else
       |          {
       |            numberStack.add( 0 );
       |          }
       |          ++ip;
       |          continue;
       |        }
       |
       |        case ParserOpcode.MUST_CONSUME_TYPE:
       |        {
       |          int tokenType = code[ ip++ ];
       |          if (nextTokenType == tokenType) read();
       |          else throwExpectedTokenTypeError( tokenType );
       |          continue;
       |        }
       |
       |        case ParserOpcode.MUST_CONSUME_STRING:
       |        {
       |          String content = peek().content;
       |          String st = strings[code[ip++]];
       |          if (content != null && content.equals(st)) read();
       |          else throwExpectedInputError( "'" + st + "'" );
       |          continue;
       |        }
       |
       |        case ParserOpcode.SAVE_POSITION:
       |          savedPositions.add( new ParsePosition(position,cmdQueue.size(),curToken) );
       |          continue;
       |
       |        case ParserOpcode.RESTORE_POSITION:
       |        {
       |          int count = savedPositions.size();
       |          if (count == 0) throw peek().error( "[INTERNAL] No savePosition to restore." );
       |          ParsePosition savedPosition = savedPositions.remove( count - 1 );
       |          position = savedPosition.position;
       |          int discardFrom = savedPosition.cmdCount;
       |          while (cmdQueue.size() > discardFrom) cmdQueue.remove( cmdQueue.size() - 1 );
       |          curToken = savedPosition.curToken;
       |          if (position < tokens.length) nextTokenType = tokens[position].type;
       |          else                          nextTokenType = -1;
       |          continue;
       |        }
       |
       |        case ParserOpcode.DISCARD_POSITION:
       |        {
       |          int count = savedPositions.size();
       |          if (count > 0) savedPositions.remove( count - 1 );
       |          continue;
       |        }
       |
       |        case ParserOpcode.TRACE:
       |          ++ip;
       |          trace( ip-1, code[ip-1] );
       |          continue;
       |
       |        case ParserOpcode.PRINTLN_STRING:
       |          System.out.println( strings[ code[ip++] ] );
       |          continue;
       |
       |        case ParserOpcode.PRINTLN_NUMBER:
       |          System.out.println( numberStack.removeLast() );
       |          continue;
       |
       |        case ParserOpcode.POP_DISCARD:
       |          numberStack.removeLast();
       |          continue;
       |
       |        case ParserOpcode.PUSH_INT32:
       |          numberStack.add( code[ip++] );
       |          continue;
       |
       |        case ParserOpcode.DECLARE_VAR:
       |        {
       |          String name = strings[ code[ip++] ];
       |          int index = locateVar( name, varFrames.last(), false );
       |          if (index != -1)
       |          {
       |            throw new Error( "[INTERNAL] A variable named '" + name + "' has already been declared in the current method." );
       |          }
       |          else
       |          {
       |            varNames.add( name );
       |            varValues.add( numberStack.removeLast() );
       |          }
       |          continue;
       |        }
       |
       |        case ParserOpcode.WRITE_VAR:
       |        {
       |          String name = strings[ code[ip++] ];
       |          int index = locateVar( name, 0, true );
       |          varValues.set( index, numberStack.removeLast() );
       |          continue;
       |        }
       |
       |        case ParserOpcode.READ_VAR:
       |        {
       |          String name = strings[ code[ip++] ];
       |          int index = locateVar( name, 0, true );
       |          numberStack.add( varValues.get(index) );
       |          continue;
       |        }
       |
       |        case ParserOpcode.LOGICAL_NOT:
       |          numberStack.add( (numberStack.removeLast()==0) ? 1 : 0 );
       |          continue;
       |
       |        case ParserOpcode.COMPARE_EQ:
       |        {
       |          int b = numberStack.removeLast();
       |          numberStack.add( (numberStack.removeLast()==b) ? 1 : 0 );
       |          continue;
       |        }
       |
       |        case ParserOpcode.COMPARE_NE:
       |        {
       |          int b = numberStack.removeLast();
       |          numberStack.add( (numberStack.removeLast()!=b) ? 1 : 0 );
       |          continue;
       |        }
       |
       |        case ParserOpcode.COMPARE_LT:
       |        {
       |          int b = numberStack.removeLast();
       |          numberStack.add( (numberStack.removeLast()<b) ? 1 : 0 );
       |          continue;
       |        }
       |
       |        case ParserOpcode.COMPARE_LE:
       |        {
       |          int b = numberStack.removeLast();
       |          numberStack.add( (numberStack.removeLast()<=b) ? 1 : 0 );
       |          continue;
       |        }
       |
       |        case ParserOpcode.COMPARE_GT:
       |        {
       |          int b = numberStack.removeLast();
       |          numberStack.add( (numberStack.removeLast()>b) ? 1 : 0 );
       |          continue;
       |        }
       |
       |        case ParserOpcode.COMPARE_GE:
       |        {
       |          int b = numberStack.removeLast();
       |          numberStack.add( (numberStack.removeLast()>=b) ? 1 : 0 );
       |          continue;
       |        }
       |
       |        default:
       |          throw new Error( "[INTERNAL] Unhandled parser opcode: " + opcode );
       |      }
       |    }
       |  }
       |
       |  public boolean hasAnother()
       |  {
       |    return (position < tokens.length);
       |  }
       |
       |  public int locateVar( String name, int lowestIndex, boolean mustLocate )
       |  {
       |    for (int index=varValues.count; --index>=lowestIndex; )
       |    {
       |      if (varNames.get(index).equals(name)) return index;
       |    }
       |    if (mustLocate) throw new Error( "[INTERNAL] No parse rule or variable named '" + name + "' has been declared." );
       |    return -1;
       |  }
       |
       |  public Cmd parse( int address )
       |  {
       |    execute( address );
       |    if (cmdQueue.isEmpty()) return null;
       |    return cmdQueue.remove( cmdQueue.size() - 1 );
       |  }
       |
       |  public Token peek()
       |  {
       |    if (position == tokens.length)
       |    {
       |      if (tokens.length == 0) return new Token( 0, null, filepath, "", 0, 0 );
       |      Token t = tokens[ tokens.length-1 ].cloned( TokenType.EOI );
       |      ++t.column;
       |      return t;
       |    }
       |    else
       |    {
       |      return tokens[ position ];
       |    }
       |  }
       |
       |  public Token read()
       |  {
       |    if (++position < tokens.length) nextTokenType = tokens[position].type;
       |    else                           nextTokenType = -1;
       |    return tokens[ position-1 ];
       |  }
       |
       |  public void throwExpectedInputError( String expected )
       |  {
       |    throw peek().error(
       |      "Syntax error - expected " + expected +
       |      ", found " + ((nextTokenType!=-1) ? StringUtility.quoted(peek().toString()) : "end of input") + "." );
       |  }
       |
       |  public void throwExpectedTokenTypeError( int tokenType )
       |  {
       |    // Single-quote any type that don't contain content.
       |    // Symbol identifier -> identfier, * -> '*'
       |    String expected = TokenType.symbols[ tokenType ];
       |    if (0 == (TokenType.attributes[tokenType] & TokenTypeAttribute.CONTENT))
       |    {
       |      expected = StringUtility.quoted( expected );
       |    }
       |    throwExpectedInputError( expected );
       |  }
       |
       |  public void throwSyntaxError()
       |  {
       |    if (position == tokens.length)
       |    {
       |      throw peek().error( "Syntax error - unexpected end of input." );
       |    }
       |    else
       |    {
       |      Token t = tokens[ position ];
       |      String sym = StringUtility.quoted( TokenType.symbols[t.type] );
       |      throw t.error( "Syntax error - unexpected " + sym + "." );
       |    }
       |  }
       |
       |  public void trace( int ip, int line )
       |  {
       |    if (line > 0)
       |    {
       |      System.out.print( "Line " );
       |      System.out.print( line );
       |      System.out.print( " " );
       |    }
       |
       |    System.out.print( "peek:" );
       |    if (nextTokenType != -1) System.out.print( peek() );
       |    else                     System.out.print( "end of input" );
       |    System.out.print( " opcode:" );
       |    System.out.print( code[ip] );
       |    System.out.println();
       |    System.out.print( "  " );
       |    for (int index=0; index<methodStack.count; ++index)
       |    {
       |      if (index > 0) System.out.print( " > " );
       |      System.out.print( methodNamesByAddress.get( methodStack.get(index) ) );
       |    }
       |    System.out.println();
       |    System.out.print( "  [" );
       |    for (int index=0; index<cmdQueue.size(); ++index)
       |    {
       |      Cmd cmd = cmdQueue.get( index );
       |      if (index > 0) System.out.print( "," );
       |      if (cmd == null)
       |      {
       |        System.out.print( "null" );
       |      }
       |      else
       |      {
       |        String name = cmd.getClass().getName();
       |        int i = name.lastIndexOf( "Cmd" );
       |        if (i != -1) name = name.substring( i+4 );
       |        i = name.lastIndexOf( "$" );
       |        if (i != -1) name = name.substring( i+1 );
       |        i = name.lastIndexOf( "." );
       |        if (i != -1) name = name.substring( i+1 );
       |        System.out.print( name );
       |      }
       |    }
       |    System.out.println( "]" );
       |  }
       |
       |  static public class ParsePosition
       |  {
       |    public int   position;
       |    public int   cmdCount;
       |    public Token curToken;
       |
       |    public ParsePosition( int position, int cmdCount, Token curToken )
       |    {
       |      this.position  = position;
       |      this.cmdCount = cmdCount;
       |      this.curToken  = curToken;
       |    }
       |  }
       |}
       |
endAugment

