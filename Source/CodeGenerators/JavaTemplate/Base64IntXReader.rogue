augment JavaTemplate
  PROPERTIES
    base64_intx_reader =
      @|<froley.package>
       |
       |class Base64IntXReader
       |{
       |  public String        data;
       |  public StringBuilder builder = new StringBuilder();
       |  public int           remainingBase64;
       |  public int           position;
       |  public int           available;
       |  public int           nextByte;
       |  public int           nextNextByte;
       |
       |  public Base64IntXReader( String encoded )
       |  {
       |    while ((encoded.length() & 3) != 0) encoded += '=';
       |
       |    remainingBase64 = (encoded.length() * 3) / 4;
       |    for (int i=encoded.length(); --i>=0;)
       |    {
       |      if (encoded.charAt(i) != '=') break;
       |      --remainingBase64;
       |    }
       |    data = encoded;
       |  }
       |
       |  public boolean hasAnother()
       |  {
       |    return (remainingBase64 > 0);
       |  }
       |
       |  public int readInt32X()
       |  {
       |    // Reads a variable-length encoded value that is stored in 1..5 bytes.
       |    // Encoded values are treated as signed.
       |    //
       |    // - If the first two bits are not "10" then the first byte is cast to
       |    //   a signed integer value and returned. This allows for the range
       |    //   -64..127 using the following bit patterns:
       |    //
       |    //     0xxxxxxx    0 .. 127
       |    //     11xxxxxx  -64 ..  -1
       |    //
       |    // - If the first two bits are "10" then the data has been encoded
       |    //   in the next 6 bits as well as any number of following bytes,
       |    //   using 7 data bits per byte with an MSBit of 0 representing a halt
       |    //   or 1 a continuation. The next bit after the leading 10 is
       |    //   treated as negative magnitude.
       |    //
       |    //     10xxxxxx 0yyyyyyy            (13-bit number xxxxxxyyyyyyy)
       |    //     10xxxxxx 1yyyyyyy 0zzzzzzz   (20-bit number xxxxxxyyyyyyyzzzzzzz)
       |    //     etc.
       |    int b = readBase64();
       |    if ((b & 0xc0) != 0x80)
       |    {
       |      // leftmost 2 bits are not %10
       |      if (b < 128) return b;        // unsigned 0..127 is fine as-is
       |      else         return b - 256;  // Convert unsigned 192..255 into -64..127
       |    }
       |
       |    int result = (b & 0x3f);        //  0..63  (unsigned)
       |    if (result >= 32) result -= 64; // -64..63 (signed)
       |
       |    for (;;)
       |    {
       |      int next = readBase64();
       |      result = (result << 7) | (next & 0x7f);
       |      if (0 == (next & 0x80)) break;
       |    }
       |
       |    return result;
       |  }
       |
       |  public String readString()
       |  {
       |    builder.clear();
       |    int n = readInt32X();
       |    for (int i=n; --i>=0;)
       |    {
       |      builder.writeUnicode( readInt32X() );
       |    }
       |    return builder.toString();
       |  }
       |
       |  public int readBase64()
       |  {
       |    if (remainingBase64 == 0) return 0;
       |    --remainingBase64;
       |
       |    if (--available >= 0)
       |    {
       |      int result = nextByte;
       |      nextByte = nextNextByte;
       |      return result;
       |    }
       |
       |    int b1 = base64ToValue( position );
       |    int b2 = base64ToValue( position+1 );
       |    int b3 = base64ToValue( position+2 );
       |    int b4 = base64ToValue( position+3 );
       |    position += 4;
       |
       |    int result = (b1 << 2) | (b2 >> 4);
       |    nextByte = ((b2 & 15) << 4) | (b3 >> 2);
       |    nextNextByte = ((b3 & 3) << 6) | b4;
       |    available = 2;
       |    return result;
       |  }
       |
       |  public int base64ToValue( int pos )
       |  {
       |    int base64 = data.charAt( pos );
       |    if (base64 >= 'A' && base64 <= 'Z') return (base64 - 'A');
       |    if (base64 >= 'a' && base64 <= 'z') return (base64 - 'a') + 26;
       |    if (base64 >= '0' && base64 <= '9') return (base64 - '0') + 52;
       |    if (base64 == '+') return 62;
       |    return 63;
       |  }
       |}
endAugment
