augment RogueTemplate
  PROPERTIES
    parser =
      @|$include "RogueFroleyCmd.rogue"
       |$include "RogueFroleyCmdInitArgs.rogue"
       |$include "RogueFroleyCmdFactory.rogue"
       |$include "RogueFroleyCode.rogue"
       |$include "RogueFroleyError.rogue"
       |$include "RogueFroleyParserOpcode.rogue"
       |$include "RogueFroleyToken.rogue"
       |$include "RogueFroleyTokenType.rogue"
       |$include "RogueFroleyTokenizerOpcode.rogue"
       |$include "RogueFroleyTokenizer.rogue"
       |
       |class RogueFroleyParser
       |  DEFINITIONS
       |    VERSION     = 1
       |    MIN_VERSION = 1
       |
       |  PROPERTIES
       |    filepath        : String
       |    code            = Int32[]
       |    strings         = String[]
       |    tokens          = RogueFroleyToken[]
       |    methods         = LookupList<<Int32>>()
       |
       |    call_stack      = Int32[]
       |    method_stack    = Int32[]
       |    token_stack     = RogueFroleyToken[]
       |    number_stack    = Real64[]
       |
       |    vars            = RogueFroleyVariable[]
       |    var_frames      = Int32[].[ add(0) ]
       |
       |    saved_positions = RogueFroleyParsePosition[]
       |
       |    cmd_queue       = RogueFroleyCmd[]
       |    cmd_args        = RogueFroleyCmdInitArgs()
       |    list_start_t    = RogueFroleyToken[]
       |    list_start_pos  = Int32[]
       |
       |    position        = 0
       |    cur_token       : RogueFroleyToken
       |    next_token_type : Int32
       |
       |    methods_by_address = Table<<Int32,String>>()
       |    tokenizer          : RogueFroleyTokenizer
       |
       |  METHODS
       |    method init
       |      init( RogueFroleyCode.parser_code, RogueFroleyCode.tokenizer_code )
       |
       |    method init( data:Byte[] )
       |      load( data )
       |
       |    method init( parser_base64_code:String, tokenizer_base64_code=null:String )
       |      init( parser_base64_code.decode_base64 )
       |      if (tokenizer_base64_code) tokenizer = RogueFroleyTokenizer( tokenizer_base64_code )
       |
       |    method execute( ip:Int32 )
       |      method_stack.add( ip )
       |      loop
       |        local opcode = RogueFroleyParserOpcode( code[ip] )
       |        #println "$ $" (ip.format("04"),opcode)
       |        ++ip
       |        which (opcode)
       |          case RogueFroleyParserOpcode.SYNTAX_ERROR
       |            if (position == tokens.count)
       |              throw peek.error( "Syntax error - unexpected end of input." )
       |            else
       |              local t = tokens[ position ]
       |              throw t.error( "Syntax error - unexpected '$'." (t.type.symbol.to_escaped_ascii) )
       |            endIf
       |          case RogueFroleyParserOpcode.RETURN
       |            if (call_stack.is_empty) return
       |            ip = call_stack.remove_last
       |            method_stack.remove_last
       |            cur_token = token_stack.remove_last
       |            vars.discard_from( var_frames.remove_last )
       |            nextIteration
       |          case RogueFroleyParserOpcode.CALL
       |            call_stack.add( ip+1 )
       |            token_stack.add( cur_token )
       |            ip = code[ ip ]
       |            method_stack.add( ip )
       |            var_frames.add( vars.count )
       |            nextIteration
       |          case RogueFroleyParserOpcode.JUMP
       |            ip = code[ ip ]
       |            nextIteration
       |          case RogueFroleyParserOpcode.JUMP_IF_TRUE
       |            if (number_stack.count and number_stack.remove_last) ip = code[ ip ]
       |            else                                                 ++ip
       |            nextIteration
       |          case RogueFroleyParserOpcode.JUMP_IF_FALSE
       |            if (number_stack.count and 0 == number_stack.remove_last) ip = code[ ip ]
       |            else                                                      ++ip
       |            nextIteration
       |          case RogueFroleyParserOpcode.ON_TOKEN_TYPE
       |            if (code[ip] == next_token_type)
       |              ip += 2
       |              cur_token = read
       |            else
       |              ip = code[ ip+1 ]
       |            endIf
       |            nextIteration
       |          case RogueFroleyParserOpcode.HAS_ANOTHER
       |            number_stack.add( next_token_type != -1 )
       |            nextIteration
       |          case RogueFroleyParserOpcode.NEXT_HAS_ATTRIBUTE
       |            number_stack.add( next_token_type != -1 and (RogueFroleyTokenType(next_token_type).attributes & code[ip]) )
       |            ++ip
       |            nextIteration
       |          case RogueFroleyParserOpcode.NEXT_IS_TYPE
       |            number_stack.add( next_token_type == code[ip] )
       |            ++ip
       |            nextIteration
       |          case RogueFroleyParserOpcode.BEGIN_LIST
       |            list_start_t.add( peek )
       |            list_start_pos.add( cmd_queue.count )
       |            nextIteration
       |          case RogueFroleyParserOpcode.CREATE_CMD
       |            local cmd_type_index = code[ ip ]
       |            local arg_count = code[ ip+1 ]
       |            ip += 2
       |            cmd_args.clear
       |            if (arg_count > 0)
       |              local i1 = cmd_queue.count - arg_count
       |              if (i1 < 0)
       |                throw cur_token.error( "[INTERNAL] Command queue too small." )
       |              endIf
       |              cmd_args.add( forEach in cmd_queue from i1 )
       |              cmd_queue.discard_from( i1 )
       |            endIf
       |            cmd_queue.add( RogueFroleyCmdFactory.create_cmd(cmd_type_index,cur_token,cmd_args) )
       |            nextIteration
       |
       |          case RogueFroleyParserOpcode.CREATE_NULL_CMD
       |            cmd_queue.add( null )
       |            nextIteration
       |
       |          case RogueFroleyParserOpcode.CREATE_ARGS
       |            if (list_start_t.is_empty) throw peek.error( "[INTERNAL] No prior beginList before calling produceArgs." )
       |            local t  = list_start_t.remove_last
       |            local i1 = list_start_pos.remove_last
       |            cmd_args.clear
       |            cmd_args.add( forEach in cmd_queue from i1 )
       |            cmd_queue.discard_from( i1 )
       |            cmd_queue.add( RogueFroleyCmdArgs(t,cmd_args) )
       |            nextIteration
       |
       |          case RogueFroleyParserOpcode.CREATE_STATEMENTS
       |            if (list_start_t.is_empty) throw peek.error( "[INTERNAL] No prior beginList before calling produceStatements." )
       |            local t  = list_start_t.remove_last
       |            local i1 = list_start_pos.remove_last
       |            cmd_args.clear
       |            cmd_args.add( forEach in cmd_queue from i1 )
       |            cmd_queue.discard_from( i1 )
       |            cmd_queue.add( RogueFroleyCmdStatements(t,cmd_args) )
       |            nextIteration
       |
       |          case RogueFroleyParserOpcode.CONSUME_EOLS
       |            # Called to automatically consume EOL tokens that occur in the
       |            # midst of parsing a unary or binary operator, like "a+\nb".
       |            <handle_consume_eols>
       |            nextIteration
       |
       |          case RogueFroleyParserOpcode.CONSUME_TYPE
       |            if (next_token_type == code[ip])
       |              read
       |              number_stack.add( 1 )
       |            else
       |              number_stack.add( 0 )
       |            endIf
       |            ++ip
       |            nextIteration
       |
       |          case RogueFroleyParserOpcode.MUST_CONSUME_TYPE
       |            if (next_token_type == code[ip])
       |              read
       |              ++ip
       |              nextIteration
       |            else
       |              throw peek.error( "Expected '$', found $."(RogueFroleyTokenType(code[ip]).symbol,?:{next_token_type!=-1:"'$'"(peek->String) || "end of input"}) )
       |            endIf
       |
       |          case RogueFroleyParserOpcode.SAVE_POSITION
       |            saved_positions.add( RogueFroleyParsePosition(position,cmd_queue.count,cur_token) )
       |            nextIteration
       |
       |          case RogueFroleyParserOpcode.RESTORE_POSITION
       |            if (saved_positions.is_empty) throw peek.error( "[INTERNAL] No savePosition to restore." )
       |            local pos = saved_positions.remove_last
       |            position = pos.position
       |            cmd_queue.discard_from( pos.cmd_count )
       |            cur_token = pos.cur_token
       |            if (position < tokens.count) next_token_type = tokens[position].type->Int32
       |            else                         next_token_type = -1
       |            nextIteration
       |
       |          case RogueFroleyParserOpcode.DISCARD_SAVED_POSITION
       |            if (saved_positions.count) saved_positions.remove_last
       |            nextIteration
       |
       |          case RogueFroleyParserOpcode.TRACE
       |            print( "Line " ).print( code[ip] ).print( " next:" )
       |            if (next_token_type != -1) print( peek )
       |            else                       print( "end of input" )
       |            ++ip
       |            print( " opcode:" ).print( RogueFroleyParserOpcode(code[ip]) )
       |            println
       |            print "  "
       |            forEach (m_ip at index in method_stack)
       |              if (index > 0) print " > "
       |              print methods_by_address[ m_ip ]
       |            endForEach
       |            println
       |            print "  ["
       |            forEach (cmd at index in cmd_queue)
       |              if (index > 0) print ","
       |              print select{ cmd:cmd.type_name || "null" }
       |            endForEach
       |            println "]"
       |            nextIteration
       |
       |          case RogueFroleyParserOpcode.PRINTLN_STRING
       |            println strings[ code[ip] ]
       |            ++ip
       |            nextIteration
       |
       |          case RogueFroleyParserOpcode.PRINTLN_NUMBER
       |            local value = number_stack.remove_last
       |            if (value == value.floor) println value->Int32
       |            else                      println value.format(".4")
       |            nextIteration
       |
       |          case RogueFroleyParserOpcode.POP_DISCARD
       |            number_stack.remove_last
       |            nextIteration
       |
       |          case RogueFroleyParserOpcode.PUSH_INT32
       |            number_stack.add( code[ip] )
       |            ++ip
       |            nextIteration
       |
       |          case RogueFroleyParserOpcode.DECLARE_VAR
       |            local name = strings[ code[ip] ]
       |            ++ip
       |            local index = locate_var( name, var_frames.last )
       |            if (index.exists)
       |              throw RogueFroleyError( "A variable named '$' has already been declared in the current method."(name) )
       |            else
       |              vars.add( RogueFroleyVariable(name,number_stack.remove_last) )
       |            endIf
       |            nextIteration
       |
       |          case RogueFroleyParserOpcode.WRITE_VAR
       |            local name = strings[ code[ip] ]
       |            ++ip
       |            local index = locate_var( name, 0, &must_locate ).value
       |            vars[ index ] = RogueFroleyVariable( name, number_stack.remove_last )
       |            nextIteration
       |
       |          case RogueFroleyParserOpcode.READ_VAR
       |            local name = strings[ code[ip] ]
       |            ++ip
       |            local index = locate_var( name, 0, &must_locate ).value
       |            number_stack.add( vars[index].value )
       |            nextIteration
       |
       |          case RogueFroleyParserOpcode.LOGICAL_NOT
       |            number_stack.last = not number_stack.last
       |            nextIteration
       |
       |          others
       |            throw RogueFroleyError( "[INTERNAL]", "Unhandled parser opcode: " + RogueFroleyParserOpcode(opcode) )
       |        endWhich
       |      endLoop
       |
       |    method has_another->Logical
       |      return (position < tokens.count)
       |
       |    method load( data:Byte[] )
       |      load( DataReader(data) )
       |
       |    method load( reader:DataReader )
       |      local version = reader.read_int32x
       |      require version >= MIN_VERSION
       |      local n = reader.read_int32x
       |
       |      strings.reserve( n )
       |      loop (n) strings.add( reader.read_string )
       |
       |      # Method names & addresses
       |      n = reader.read_int32x
       |      methods.reserve( n )
       |      loop (n)
       |        local name = strings[ reader.read_int32x ]
       |        methods[ name ] = reader.read_int32x
       |        methods_by_address[ methods[name] ] = name
       |      endLoop
       |
       |      n = reader.read_int32x
       |      code.reserve( n )
       |      loop (n) code.add( reader.read_int32x )
       |
       |    method locate_var( name:String, lowest_index:Int32, &must_locate )->Int32?
       |      forEach (index in vars.count-1 downTo lowest_index)
       |        if (vars[index].name == name) return index
       |      endForEach
       |      if (must_locate) throw RogueFroleyError( "No variable named '$' has been declared."(name) )
       |      return null
       |
       |    method parse( rule_name:String )->RogueFroleyCmd
       |      local index = methods.locate( rule_name )
       |      if (not index.exists) throw RogueFroleyError( "[INTERNAL]", "No parse rule '$' exists."(rule_name) )
       |      return parse( methods[index.value] )
       |
       |    method parse( address:Int32 )->RogueFroleyCmd
       |      call_stack.clear
       |      cmd_queue.clear
       |      execute( address )
       |      if (cmd_queue.count) return cmd_queue.remove_last
       |      else                 return null
       |
       |    method peek->RogueFroleyToken
       |      if (position == tokens.count)
       |        if (tokens.is_empty) return RogueFroleyToken( filepath, "", 0, 0, RogueFroleyTokenType(0) )
       |        local t = tokens.last.cloned
       |        ++t.column
       |        return t
       |      else
       |        return tokens[ position ]
       |      endIf
       |
       |    method read->RogueFroleyToken
       |      ++position
       |      if (position < tokens.count) next_token_type = tokens[position].type->Int32
       |      else                         next_token_type = -1
       |      return tokens[ position-1 ]
       |
       |    method open( filepath, content:String, start_line=1:Int32, start_column=1:Int32 )
       |      require tokenizer
       |      open( filepath, tokenizer.tokenize(filepath,content,start_line,start_column) )
       |
       |    method open( file:File )
       |      require tokenizer
       |      open( file.filepath, tokenizer.tokenize(file) )
       |
       |    method open( filepath, tokens:RogueFroleyToken[] )
       |      @tokens.clear
       |      @tokens.add( tokens )
       |      if (tokens.count)
       |        next_token_type = tokens.first.type->Int32
       |      else
       |        next_token_type = -1
       |      endIf
       |      position = 0
       |      cur_token = null
       |
       |
       |endClass
       |
       |class RogueFroleyVariable( name:String, value:Real64 ) [compound]
       |endClass
       |
       |class RogueFroleyParsePosition( position:Int32, cmd_count:Int32, cur_token:RogueFroleyToken ) [compound]
       |endClass
       |
endAugment

