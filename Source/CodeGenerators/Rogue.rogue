module Froley

Froley.code_generators//rogue = GenerateRogue()

class GenerateRogue : CodeGenerator
  PROPERTIES
    source_timestamp          : Real64
    should_generate_framework : Logical
    should_generate_main      : Logical

  METHODS
    method usage_options->String[]
      return prior.usage_options.add(
        @|    --framework
         |      Creates the following framework files for language "XYZ" if they do not
         |      exist:
         |        - XYZError.rogue, XYZParser.rogue, XYZToken.rogue, XYZTokenizer.rogue
         |      Updates XYZCmd.rogue with starter class definitions of any command nodes
         |      that are not yet defined. Does not delete any code.
      ).add(
        @|    --main
         |      Creates a main file (if it does not yet exist) to test out the parser
         |      and tokenizer. Implies '--framework`.
      )

    method add_option( name:String, value:String )
      which (name)
        case "framework"
          should_generate_framework = true
          if (value != "") throw FroleyError( "The --framework option should not have any arguments." )
        case "main"
          should_generate_main = true
          should_generate_framework = true
          if (value != "") throw FroleyError( "The --main option should not have any arguments." )
        others
          prior.add_option( name, value )
      endWhich

    method output_filepath( filename:String, &do_not_overwrite, &for_reading )->String
      local filepath = select{options//output||""} + language + filename
      if (for_reading) return filepath

      if (File.timestamp(filepath) >= source_timestamp) return null

      if (File.exists(filepath))
        if (do_not_overwrite) return null
        println "Regenerating " + filepath
      else
        println "Creating " + filepath
      endIf

      return filepath

    method output_writer( filename:String, &do_not_overwrite )->PrintWriter
      local filepath = output_filepath( filename, &=do_not_overwrite )
      if (not filepath) return null

      local writer = PrintWriter( File.writer(filepath) )
      if (not do_not_overwrite)
        writer.println @|# WARNING: This file will be automatically regenerated by the Froley compiler.
                        |# Any edits will be lost!
        writer.println
      endIf
      return writer

    method process( info )
      language = info//language
      source_timestamp = File.timestamp( info//source_filepath )

      if (should_generate_framework)
        generate_Cmd
        generate_CmdInitArgs
        generate_Error
        generate_Parser
        generate_Token
        generate_Tokenizer
        if (should_generate_main) generate_main
      endIf

      regenerate_CmdFactory
      regenerate_Code
      regenerate_ParserOpcode
      regenerate_TokenType
      regenerate_TokeninzerOpcode

    method generate( content:String, filename:String, content_filter=null:Function(String)->String, &do_not_overwrite )
      local writer = output_writer( filename, &=do_not_overwrite )
      if (not writer) return
      if (content_filter) content = content_filter( content )
      content = content.replacing( "RogueFroley", language )
      writer.println( content )
      writer.close

    method generate_Cmd
      generate( RogueTemplate.cmd, "Cmd.rogue", &do_not_overwrite )

      # Update Cmd.rogue by adding new class skeletons
      local filepath = output_filepath( "Cmd.rogue", &for_reading )
      local content = File.load_as_string( filepath )
      local builder : StringBuilder
      forEach (cmd_type in info//cmd_types)
        local base_name = (cmd_type//name)->String
        local class_name = language + base_name
        local class_class_name = "class " + class_name
        if (not content.contains(class_class_name))
          if (not builder)
            println "Updating " + filepath
            builder = StringBuilder( content.count * 1.5 )
            builder.println( content )
          endIf
          local type = ParseRuleType( cmd_type//type )
          print( "  " ).println( class_class_name )
          builder.println.print( class_class_name )

          local cmd_properties = cmd_type//properties
          if (cmd_properties.count)
            builder.print( "( t" )
            forEach (p in cmd_properties)
              builder.print( ", " )
              builder.print( p//name )
              builder.print( ':' )
              if (p//value.count)
                builder.print( p//type )
              else
                builder.print( language ).print( p//type )
              endIf
            endForEach
            builder.print( " )" )
          endIf

          builder.print( " : " ).print( language ).print( "Cmd" )
          which (type)
            case ParseRuleType.PRE_UNARY:  builder.println "Unary"
            case ParseRuleType.POST_UNARY: builder.println "PostUnary"
            case ParseRuleType.BINARY:     builder.println "Binary"
            case ParseRuleType.STATEMENTS: builder.println "Statements"
            case ParseRuleType.ARGS:       builder.println "Args"
            others
              builder.println
          endWhich
          builder.println "  METHODS"
          if (cmd_properties.count)
            builder.print(   "    method init( t, args:" ).print( language ).println( "CmdInitArgs )" )
            builder.print(   "      args.require_count( " ).print( cmd_type//properties.count($//value=="") ).println( " )" )
            local index = 0
            forEach (p in cmd_properties)
              builder.print( "      " )
              builder.print( p//name )
              builder.print( " = " )
              if (p//value != "")
                builder.print( p//value )
                if (p//type != "String") builder.print( "->" ).print( p//type )
              else
                builder.print( "args[ " ).print( index ).print( " ]" )
                ++index
              endIf
              builder.println
            endForEach
            builder.println
          endIf

          local escaped_symbol = cmd_type//symbol->String.to_escaped_ascii("\"")
          which (type)
            case ParseRuleType.PRE_UNARY, ParseRuleType.POST_UNARY, ParseRuleType.BINARY
              builder.println "    method op->String"
              builder.println '      return "$"' (escaped_symbol)
            others
              builder.println "    method write( builder:StringBuilder )"
              builder.print  ("      builder.print " )
              which (cmd_properties.count)
                case 0
                  builder.print( '"' ).print( escaped_symbol ).println( '"' )
                case 1
                  local p = cmd_properties[ 0 ]
                  if (p//value != "")
                    builder.print( p//name )
                    if (p//type != "String") builder.print( "->String" )
                  else
                    builder.print( '"' )
                    builder.print( escaped_symbol ).print( "($)" )
                    builder.print( '"' )
                    builder.print( '(' )
                    builder.print( p//name )
                    builder.print( ')' )
                  endIf
                  builder.println
                others
                  builder.print( '"' )
                  builder.print( escaped_symbol ).print( '(' )
                  forEach (p at index in cmd_properties)
                    if (index > 0) builder.print( ',' )
                    builder.print( '$' )
                  endForEach
                  builder.print( ')' )
                  builder.print( '"' )
                  builder.print( '(' )
                  forEach (p at index in cmd_properties)
                    if (index > 0) builder.print( ',' )
                    builder.print( p//name )
                  endForEach
                  builder.println( ')' )
              endWhich
          endWhich
          builder.println "endClass"
        endIf
      endForEach
      if (builder)
        File.save( filepath, builder->String )
      endIf

    method generate_CmdInitArgs
      generate( RogueTemplate.cmd_init_args, "CmdInitArgs.rogue", &do_not_overwrite )

    method generate_Error
      generate( RogueTemplate.error, "Error.rogue", &do_not_overwrite )

    method generate_main
      generate( RogueTemplate.main, ".rogue", &do_not_overwrite )

    method generate_Parser
      local fn = function( content:String )->String
        local def = Froley.token_defs_by_symbol[ "\n" ]
        if (def) content = content.replacing( "<handle_consume_eols>", "while (RogueFroleyTokenType(next_token_type) == RogueFroleyTokenType.$) read"(def.name) )
        return content
      endFunction
      generate( RogueTemplate.parser, "Parser.rogue", fn, &do_not_overwrite )

    method generate_Token
      generate( RogueTemplate.token, "Token.rogue", &do_not_overwrite )

    method generate_Tokenizer
      local fn = function( content:String )->String with (info)
        local def = Froley.token_defs_by_symbol[ "\n" ]
        content = content.replacing( "<id_start>", info//id_characters//start->String.to_escaped_ascii("\"") )
        content = content.replacing( "<id_continue>", info//id_characters//continue->String.to_escaped_ascii("\"") )
        return content
      endFunction
      generate( RogueTemplate.tokenizer, "Tokenizer.rogue", fn, &do_not_overwrite )

    method regenerate_CmdFactory
      local writer = output_writer( "CmdFactory.rogue" )
      if (not writer) return

      writer.print  ( "class ").print( language ).println( "CmdFactory" )
      writer.println( "  GLOBAL METHODS" )
      writer.print  ( "    method create_cmd( index:Int32, t:" ).print( language ).print( "Token, args:" ).print( language ).print( "CmdInitArgs )->" ) ...
        .print( language ).println( "Cmd" )
      writer.println("      which (index)")
      forEach (cmd_type in info//cmd_types)
        writer.print  ( "        case " ).print( cmd_type//index ).print( ": " )
        writer.print  ( "return " ).print( language ).print( cmd_type//name ).println( "( t, args )" )
      endForEach
      writer.println @|        others
      writer.print  ( "          throw " ).print( language ).println( ''Error( "[INTERNAL] CmdFactory.create_cmd() index out of bounds: " + index )'' )
      writer.println @|      endWhich
                      |endClass
      writer.close

    method regenerate_Code
      local writer = output_writer( "Code.rogue" )
      if (not writer) return

      writer.print  ( "class " ).print( language ).println( "Code" )
      writer.println @|  GLOBAL PROPERTIES
                      |    tokenizer_code =
      writer.print    "      \""
      writer.print   info//tokenizer_code->String.word_wrap(64).join( "\" ...\n      \"" )
      writer.println "\""
      writer.println
      writer.println

      writer.println "    parser_code ="
      writer.print   "      \""
      writer.print   info//parser_code->String.word_wrap(64).join( "\" ...\n      \"" )
      writer.println "\""
      writer.println
      writer.println

      writer.println "endClass"
      writer.close

    method regenerate_ParserOpcode
      local writer = output_writer( "ParserOpcode.rogue" )
      if (not writer) return

      local defs = Int32DefsBuilder( &prefix="  " )
      forEach (parser_opcode in info//parser_opcodes)
        defs.add( parser_opcode//name, parser_opcode//value )
      endForEach

      writer.print  ( "enum ").print( language ).print( "ParserOpcode" )
      defs.print( writer )
      writer.println @|endEnum
      writer.close

    method regenerate_TokenType
      local writer = output_writer( "TokenType.rogue" )
      if (not writer) return

      local attributes_by_value = Table<<Int32,String>>()
      local defs = Int32DefsBuilder( &prefix="  " )
      defs.add( "NONE", 0 )
      forEach (attribute in info//token_attributes)
        local name = attribute//name->String.to_uppercase
        defs.add( name, attribute//value )
        attributes_by_value[ attribute//value ] = name
      endForEach

      writer.print  ( "enum ").print( language ).println( "TokenTypeAttribute" )
      defs.print( writer )
      writer.println @|endEnum
      writer.println.println

      defs = Int32DefsBuilder( &prefix="  " )
      forEach (token_type in info//token_types)
        local def = '$("$"' (token_type//name,token_type//symbol->String.to_escaped_ascii("\""))
        local attributes = token_type//attributes->Int32
        if (attributes)
          def += "," + language + "TokenTypeAttribute"
          local name = attributes_by_value[ attributes ]
          if (name) def += "." + name
          else      def += "($)" (attributes)
        endIf
        def += ")"
        defs.add( def, token_type//type )
      endForEach

      writer.print  ( "enum ").print( language ).print( "TokenType( symbol:String, attributes=" ).print( language ).print( "TokenTypeAttribute.NONE:" )
      writer.print( language ).println( "TokenTypeAttribute )" )
      defs.print( writer )
      writer.println @|endEnum
      writer.close

    method regenerate_TokeninzerOpcode
      local writer = output_writer( "TokenizerOpcode.rogue" )
      if (not writer) return

      local defs = Int32DefsBuilder( &prefix="  " )
      forEach (tokenizer_opcode in info//tokenizer_opcodes)
        defs.add( tokenizer_opcode//name, tokenizer_opcode//value )
      endForEach

      writer.print  ( "enum ").print( language ).print( "TokenizerOpcode" )
      defs.print( writer )
      writer.println @|endEnum
      writer.close
endClass
