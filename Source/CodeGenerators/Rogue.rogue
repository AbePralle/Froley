module Froley

$include "Template/RogueFroleyError.rogue"

Froley.code_generators//rogue = GenerateRogue()

# Simple.rogue
# SimpleCmd.rogue
# SimpleError.rogue
# SimpleParserVM.rogue
# SimpleToken.rogue
# SimpleTokenizerVM.rogue

class GenerateRogue : CodeGenerator
  PROPERTIES
    source_timestamp   : Real64
    generate_framework : Logical

  METHODS
    method usage_options->String[]
      return prior.usage_options.add(
        @|    --framework
         |      Creates the following framework files for language "XYZ" if they do not
         |      exist:
         |        - XYZError.rogue, XYZParser.rogue, XYZToken.rogue, XYZTokenizer.rogue
         |      Updates XYZCmd.rogue with starter class definitions of any command nodes
         |      that are not yet defined. Does not delete any code.
      )

    method add_option( name:String, value:String )
      which (name)
        case "framework"
          generate_framework = true
          if (value != "") throw FroleyError( "The --framework option should not have any arguments." )
        others
          prior.add_option( name, value )
      endWhich

    method process( info )
      language = info//language
      source_timestamp = File.timestamp( info//source_filepath )

      regenerate_CmdFactory
      regenerate_Code
      regenerate_ParserOpcode
      regenerate_TokenType
      regenerate_TokeninzerOpcode

      if (generate_framework)
        generate_Error
      endIf

    method generate( content:String, output_filepath:String )
      if (File.exists(output_filepath)) return
      println "Creating " + output_filepath
      File.save( output_filepath, content.replacing("RogueFroley",language) )

    method generate_Error
      generate( rogue_froley_error, language + "Error.rogue" )

    method regenerate_CmdFactory
      local filepath = select{options//output||""} + language + "CmdFactory.rogue"
      if (File.timestamp(filepath) >= source_timestamp) return

      println "Writing " + filepath

      local writer = PrintWriter( File.writer(filepath) )
      writer.println @|# WARNING: This file will be automatically regenerated by the Froley compiler. Any edits will be lost!
      writer.print  ( "class ").print( language ).print( "CmdFactory" )
      writer.println( "  GLOBAL METHODS" )
      writer.print  ( "    method create_cmd( index:Int32, t:" ).print( language ).print( "Token, args:" ).print( language ).print( "Cmd[] )->" ) ...
        .print( language ).println( "Cmd" )
      writer.println("      which (index)")
      forEach (cmd_type_name at index in info//parser_cmd_type_names)
        writer.print  ( "        case " ).print( index ).print( ": " )
        writer.print  ( "return " ).print( cmd_type_name ).println( "( t, args )" )
      endForEach
      writer.println @|        others
      writer.print  ( "          throw " ).print( language ).println( ''Error( "[INTERNAL] CmdFactory.create_cmd() index out of bounds: " + index )'' )
      writer.println @|      endWhich
                      |endClass
      writer.close

    method regenerate_Code
      local filepath = select{options//output||""} + language + "Code.rogue"
      if (File.timestamp(filepath) >= source_timestamp) return

      println "Writing " + filepath

      local writer = PrintWriter( File.writer(filepath) )
      writer.println @|# WARNING: This file will be automatically regenerated by the Froley compiler. Any edits will be lost!
                      |class Code
                      |  GLOBAL PROPERTIES
                      |    tokenizer_code =
      forEach (line at index in info//tokenizer_code->String.word_wrap(64))
        if (index > 0) writer.println( " ..." )
        writer.print '      "'
        writer.print line
        writer.print '"'
      endForEach
      writer.println
      writer.println

      writer.println "    parser_code ="
      forEach (line at index in info//parser_code->String.word_wrap(64))
        if (index > 0) writer.println( " ..." )
        writer.print '      "'
        writer.print line
        writer.print '"'
      endForEach
      writer.println
      writer.println

      writer.println "endClass"
      writer.close

    method regenerate_ParserOpcode
      local filepath = select{options//output||""} + language + "ParserOpcode.rogue"
      if (File.timestamp(filepath) >= source_timestamp) return

      println "Writing " + filepath

      local defs = Int32DefsBuilder( &prefix="  " )
      forEach (parser_opcode in info//parser_opcodes)
        defs.add( parser_opcode//name, parser_opcode//value )
      endForEach

      local writer = PrintWriter( File.writer(filepath) )
      writer.println @|# WARNING: This file will be automatically regenerated by the Froley compiler. Any edits will be lost!
      writer.print  ( "enum ").print( language ).print( "ParserOpcode" )
      defs.print( writer )
      writer.println @|endEnum
      writer.close

    method regenerate_TokenType
      local filepath = select{options//output||""} + language + "TokenType.rogue"
      if (File.timestamp(filepath) >= source_timestamp) return

      println "Writing " + filepath

      local defs = Int32DefsBuilder( &prefix="  " )
      forEach (token_type in info//token_types)
        defs.add( '$("$")' (token_type//name,token_type//symbol->String.to_escaped_ascii("\"")), token_type//type )
      endForEach

      local writer = PrintWriter( File.writer(filepath) )
      writer.println @|# WARNING: This file will be automatically regenerated by the Froley compiler. Any edits will be lost!
      writer.print  ( "enum ").print( language ).print( "TokenType( symbol:String )" )
      defs.print( writer )
      writer.println @|endEnum
      writer.close

    method regenerate_TokeninzerOpcode
      local filepath = select{options//output||""} + language + "TokenizerOpcode.rogue"
      if (File.timestamp(filepath) >= source_timestamp) return

      println "Writing " + filepath

      local defs = Int32DefsBuilder( &prefix="  " )
      forEach (tokenizer_opcode in info//tokenizer_opcodes)
        defs.add( tokenizer_opcode//name, tokenizer_opcode//value )
      endForEach

      local writer = PrintWriter( File.writer(filepath) )
      writer.println @|# WARNING: This file will be automatically regenerated by the Froley compiler. Any edits will be lost!
      writer.print  ( "enum ").print( language ).print( "TokenizerOpcode" )
      defs.print( writer )
      writer.println @|endEnum
      writer.close
endClass
