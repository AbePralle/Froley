$includeFolder "JavaTemplate"

module Froley

Froley.code_generators//java = GenerateJava()

class GenerateJava : CodeGenerator
  PROPERTIES
    package_name         : String
    should_generate_main : Logical

  METHODS
    method usage_options->String[]
      return prior.usage_options.add(
        @|    --main
         |      Creates a main file (if it does not yet exist) to test out the parser
         |      and tokenizer.
      ).add(
        @|    --package=<package-name>
         |      Specifies the package name that will be used for all generated Java files.
         |      An appropriate folder heirarchy will be created in the default or
         |      specified --output folder if needed.
      )

    method add_option( name:String, value:String )
      which (name)
        case "main"
          should_generate_main = true
          if (value != "") throw FroleyError( "The --main option should not have any arguments." )
        case "package"
          package_name = value
        others
          prior.add_option( name, value )
      endWhich

    method output_filepath( filename:String, &do_not_overwrite, &for_reading )->String
      local filepath = select{output||""} + filename
      if (for_reading) return filepath

      if (File.exists(filepath))
        if (do_not_overwrite) return null
        println "Regenerating " + filepath
      else
        println "Creating " + filepath
      endIf

      return filepath

    method output_writer( filename:String, &do_not_overwrite )->PrintWriter
      local filepath = output_filepath( filename, &=do_not_overwrite )
      if (not filepath) return null

      local writer = PrintWriter( File.writer(filepath) )
      if (not do_not_overwrite)
        writer.println @|// WARNING: This file will be automatically regenerated by the Froley compiler.
                        |// Any edits will be lost!
        writer.println
      endIf
      return writer

    method process( info )
      configure
      if (package_name) output += File.ensure_ends_with_separator( package_name.split('.').join("/") )
      File.create_folder( output )
      output = File.ensure_ends_with_separator( output )

      generate_Tokenizer
      generate( JavaTemplate.base64_intx_reader, "Base64IntXReader.java", &do_not_overwrite )
      generate( JavaTemplate.error,              "Error.java",            &do_not_overwrite )
      generate( JavaTemplate.int_list,           "IntList.java",          &do_not_overwrite )
      generate( JavaTemplate.token,              "Token.java",            &do_not_overwrite )
      generate( JavaTemplate.scanner,            "Scanner.java",          &do_not_overwrite )
      generate( JavaTemplate.string_builder,     "StringBuilder.java",    &do_not_overwrite )
      generate( JavaTemplate.string_utility,     "StringUtility.java",    &do_not_overwrite )

      regenerate_Code
      regenerate_TokenTypeAttribute
      regenerate_TokenType
      regenerate_TokenizerOpcode

      if (has_parser)
        generate_Cmd
        generate_CmdInitArgs
        generate_Parser
        regenerate_CmdFactory
        regenerate_ParserOpcode
      endIf

      if (should_generate_main) generate_main

    method generate( content:String, filename:String, content_filter=null:Function(String)->String, &do_not_overwrite )
      local writer = output_writer( filename, &=do_not_overwrite )
      if (not writer) return
      if (content_filter) content = content_filter( content )
      if (package_name)
        content = content.replacing( "<rogue.froley.package>", "package $;"(package_name) );
      else
        content = content.replacing( "<rogue.froley.package>", "" );
      endIf
      content = content.replacing( "RogueFroley", language )
      writer.println( content )
      writer.close

    method fix_type( name:String )->String
      which (name)
        case "Real64":    return "double"
        case "Real32":    return "float"
        case "Int64":     return "long"
        case "Int32":     return "int"
        case "Character": return "char"
        case "Byte":      return "byte"
        case "Logical":   return "boolean"
        others:           return name
      endWhich

    method generate_Cmd
      generate( JavaTemplate.cmd, "Cmd.java", &do_not_overwrite )

      # Update Cmd.java by adding new class skeletons
      local filepath = output_filepath( "Cmd.java", &for_reading )
      local content = File.load_as_string( filepath )

      local builder : StringBuilder
      forEach (cmd_type in info//cmd_types)
        local base_name = (cmd_type//name)->String
        local class_name = base_name
        local class_class_name = "static public class " + class_name
        if (not content.contains(class_class_name))
          if (not builder)
            println "Updating " + filepath
            builder = StringBuilder( content.count * 1.5 )
            local closing_curly_index = content.locate_last( '}' )
            if (closing_curly_index.exists)
              content = content.substring( 0, closing_curly_index.value-1 )
            endIf
            builder.println( content )
          endIf
          local type = ParseRuleType( cmd_type//type )
          print( "  class " ).println( class_name )
          builder.println.print( "  " ).print( class_class_name )
          builder.print( " extends Cmd" )
          which (type)
            case ParseRuleType.PRE_UNARY:  builder.println "Unary"
            case ParseRuleType.POST_UNARY: builder.println "PostUnary"
            case ParseRuleType.BINARY:     builder.println "Binary"
            case ParseRuleType.STATEMENTS: builder.println "Statements"
            case ParseRuleType.LIST:       builder.println "List"
            others
              builder.println
          endWhich
          builder.println( "  {" )

          local cmd_properties = cmd_type//properties
          if (cmd_properties.count)
            builder.println "    // PROPERTIES"
            forEach (p in cmd_properties)
              builder.println( "    public $ $;" (fix_type(p//type),p//name) )
            endForEach
            builder.println
          endIf

          builder.println "    // METHODS"
          if (cmd_properties.count)
            # Default constructor
            builder.println "    public $()" (class_name)
            builder.println "    {"
            builder.println "    }"
            builder.println

            # Property-setting constructor
            builder.print( "    public $( Token t" (class_name) )
            forEach (p in cmd_properties)
              builder.print( ", $ $" (fix_type(p//type),p//name) )
            endForEach
            builder.println( " )" )
            builder.println "    {"
            builder.println "      this.t = t;"
            forEach (p in cmd_properties)
              builder.println( "      this.$ = $;" (p//name,p//name) )
            endForEach
            builder.println "    }"
            builder.println

            # Systematic initializer
            builder.println(   "    public $ init( Token t, CmdInitArgs args )" (class_name) )
            builder.println( "    {" )
            builder.println(   "      args.requireCount( $ );" (cmd_type//properties.count($//value=="")) )
            builder.println(   "      this.t = t;" )
            local index = 0
            forEach (p in cmd_properties)
              builder.print( "      " )
              builder.print( p//name )
              builder.print( " = " )
              if (p//value != "")
                # name = t.content;
                # name = StringUtility.stringToInt32( t.content );
                if (p//type == "String")
                  builder.print( p//value ).println( ';' )
                else
                  builder.println( "StringUtility.stringTo$( $ );" (p//type,p//value) )
                endIf
              else
                if (p//type != "Cmd") builder.print( "($)" (fix_type(p//type)) )
                builder.println( "args.get( $ );" (index) )
                ++index
              endIf
            endForEach
            builder.println( "      return this;" )
            builder.println( "    }" )
            builder.println
          endIf

          local escaped_symbol = cmd_type//symbol->String.to_escaped_ascii("\"")
          which (type)
            case ParseRuleType.PRE_UNARY, ParseRuleType.POST_UNARY, ParseRuleType.BINARY
              builder.println "    public String op()"
              builder.println "    {"
              builder.println '      return "$";' (escaped_symbol)
              builder.println "    }"
            others
              builder.println "    public void write( StringBuilder builder )"
              builder.println "    {"
              which (cmd_properties.count)
                case 0
                  builder.println ''      builder.print( "$" );'' (escaped_symbol)
                others
                  if (cmd_properties.count > 1) builder.println ''      builder.print( "$(" );'' (escaped_symbol)
                  forEach (p at index in cmd_properties)
                    if (index > 0) builder.println ''      builder.print( ',' );''
                    if (p//value != "")
                      if (p//type == "String")
                        builder.println ''      builder.print( $ );'' (p//name)
                      else
                        builder.println ''      builder.print( ""+$ );'' (p//name)
                      endIf
                    else
                      builder.println ''      $.write( builder );'' (p//name)
                    endIf
                  endForEach
                  if (cmd_properties.count > 1) builder.println ''      builder.print( ')' );''
              endWhich
              builder.println "    }"
          endWhich
          builder.println "  }"
        endIf
      endForEach
      if (builder)
        builder.println "}"
        File.save( filepath, builder->String )
      endIf

    method generate_CmdInitArgs
      generate( JavaTemplate.cmd_init_args, "CmdInitArgs.java", &do_not_overwrite )

    method generate_main
      if (has_parser)
        generate( JavaTemplate.main_with_tokenizer_and_parser, language+".java", &do_not_overwrite )
      else
        generate( JavaTemplate.main_with_tokenizer_only, language+".java", &do_not_overwrite )
      endIf

    method generate_Parser
      local fn = function( content:String )->String
        local def = Froley.token_defs_by_symbol[ "\n" ]
        if (def)
          content = content.replacing( "<handle_consume_eols>",
              "while (nextTokenType == TokenType." + def.name + ") read();" )
        else
          content = content.replacing( "<handle_consume_eols>", "" );
        endIf
        return content
      endFunction
      generate( JavaTemplate.parser, "Parser.java", fn, &do_not_overwrite )

    method generate_Tokenizer
      local fn = function( content:String )->String with (info)
        local def = Froley.token_defs_by_symbol[ "\n" ]
        content = content.replacing( "<id_start>", info//id_characters//start->String.to_escaped_ascii("\"") )
        content = content.replacing( "<id_continue>", info//id_characters//continue->String.to_escaped_ascii("\"") )
        return content
      endFunction
      generate( JavaTemplate.tokenizer, "Tokenizer.java", fn, &do_not_overwrite )

    method regenerate_CmdFactory
      local writer = output_writer( "CmdFactory.java" )
      if (not writer) return

      if (package_name)
        writer.println( "package $;"(package_name) );
        writer.println
      endIf
      writer.println  @|class CmdFactory
                       |{
                       |  // GLOBAL METHODS
                       |  static public Cmd createCmd( int index, Token t, CmdInitArgs args )
                       |  {
                       |    switch (index)
                       |    {
      forEach (cmd_type in info//cmd_types)
        writer.println "      case $ : return new Cmd.$().init( t, args );" (cmd_type//index,cmd_type//name)
      endForEach
      writer.println  @|      default:
      writer.println( ''        throw new Error( "RogueFroley", "[INTERNAL] CmdFactory.createCmd() index out of bounds: " + index );'' )
      writer.println  @|    }
                       |  }
                       |}
      writer.close

    method regenerate_Code
      local writer = output_writer( "Code.java" )
      if (not writer) return

      if (package_name)
        writer.println( "package $;"(package_name) );
        writer.println
      endIf

      writer.println @|public class Code
                      |{
                      |  // PROPERTIES

      writer.println  "  static public String tokenizerCode =";
      writer.print    "    \""
      writer.print   info//tokenizer_code->String.word_wrap(64).join( "\" +\n    \"" )
      writer.println "\";"

      if (info//parser_code.count)
        writer.println
        writer.println "  static public String parserCode ="
        writer.print   "    \""
        writer.print   info//parser_code->String.word_wrap(64).join( "\" +\n    \"" )
        writer.println "\";"
      endIf

      writer.println "}"
      writer.close

    method regenerate_ParserOpcode
      local writer = output_writer( "ParserOpcode.java" )
      if (not writer) return

      local defs = Int32DefsBuilder( &prefix="  final static public int ", &suffix=";" )
      forEach (parser_opcode in info//parser_opcodes)
        defs.add( parser_opcode//name, parser_opcode//value )
      endForEach

      if (package_name)
        writer.println( "package $;"(package_name) );
        writer.println
      endIf
      writer.println( "public class ParserOpcode" )
      writer.println( "{" )
      defs.print( writer )
      writer.println( "}" )
      writer.close

    method regenerate_TokenTypeAttribute
      local writer = output_writer( "TokenTypeAttribute.java" )
      if (not writer) return

      local defs = Int32DefsBuilder( &prefix="  final static public int ", &suffix=";" )
      defs.add( "NONE", 0 )
      forEach (attribute in info//token_attributes)
        local name = attribute//name->String.to_uppercase
        defs.add( name, attribute//value )
      endForEach

      if (package_name)
        writer.println( "package $;"(package_name) );
        writer.println
      endIf
      writer.println @|public class TokenTypeAttribute
                      |{
      defs.print( writer )
      writer.println @|}
      writer.println

    method regenerate_TokenType
      local writer = output_writer( "TokenType.java" )
      if (not writer) return

      local attributes = ListSourceBuilder( "  static public int[] attributes =\n  {\n", "    ", "  };\n" )
      local symbols    = ListSourceBuilder( "  static public String[] symbols =\n  {\n", "    ", "  };\n" )
      attributes.add( "0" )
      symbols.add( "null" )

      local defs = Int32DefsBuilder( &prefix="  final static public int ", &suffix=";" )
      forEach (token_type in info//token_types)
        defs.add( token_type//name, token_type//type )
        attributes.add( token_type//attributes )
        symbols.add( '"$"' (token_type//symbol->String.to_escaped_ascii("\"")) )
      endForEach

      if (package_name)
        writer.println( "package $;"(package_name) );
        writer.println
      endIf
      writer.println @|public class TokenType
                      |{
      defs.print( writer )
      writer.println

      attributes.write( writer )
      writer.println

      symbols.write( writer )
      writer.println @|}

      writer.close

    method regenerate_TokenizerOpcode
      local writer = output_writer( "TokenizerOpcode.java" )
      if (not writer) return

      local defs = Int32DefsBuilder( &prefix="  final static public int ", &suffix=";" )
      forEach (tokenizer_opcode in info//tokenizer_opcodes)
        defs.add( tokenizer_opcode//name, tokenizer_opcode//value )
      endForEach

      if (package_name)
        writer.println( "package $;"(package_name) );
        writer.println
      endIf
      writer.println( "public class TokenizerOpcode" )
      writer.println( "{" )
      defs.print( writer )
      writer.println( "}" )
      writer.close
endClass
