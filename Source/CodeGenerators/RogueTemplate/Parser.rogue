augment RogueTemplate
  PROPERTIES
    parser =
      @|module RogueFroley
       |
       |$include "Cmd.rogue"
       |$include "CmdInitArgs.rogue"
       |$include "CmdFactory.rogue"
       |$include "Code.rogue"
       |$include "Error.rogue"
       |$include "ParserOpcode.rogue"
       |$include "Token.rogue"
       |$include "TokenType.rogue"
       |$include "TokenizerOpcode.rogue"
       |$include "Tokenizer.rogue"
       |
       |class Parser
       |  DEFINITIONS
       |    VERSION     = 1
       |    MIN_VERSION = 1
       |
       |  PROPERTIES
       |    filepath        : String
       |    code            = Int32[]
       |    strings         = String[]
       |    tokens          = Token[]
       |    methods         = LookupList<<Int32>>()
       |
       |    call_stack      = Int32[]
       |    method_stack    = Int32[]
       |    token_stack     = Token[]
       |    number_stack    = Real64[]
       |
       |    vars            = Variable[]
       |    var_frames      = Int32[].[ add(0) ]
       |
       |    saved_positions = ParsePosition[]
       |
       |    cmd_queue       = Cmd[]
       |    cmd_args        = CmdInitArgs()
       |    list_start_t    = Token[]
       |    list_start_pos  = Int32[]
       |
       |    position        = 0
       |    cur_token       : Token
       |    next_token_type : Int32
       |
       |    methods_by_address = Table<<Int32,String>>()
       |    tokenizer          = Tokenizer()
       |
       |  METHODS
       |    method init
       |      load( Code.parser_code )
       |
       |    method execute( ip:Int32 )
       |      method_stack.add( ip )
       |      loop
       |        local opcode = ParserOpcode( code[ip] )
       |        #println "$ $" (ip.format("04"),opcode)
       |        ++ip
       |        which (opcode)
       |          case ParserOpcode.SYNTAX_ERROR
       |            if (position == tokens.count)
       |              throw peek.error( "Syntax error - unexpected end of input." )
       |            else
       |              local t = tokens[ position ]
       |              throw t.error( "Syntax error - unexpected '$'." (t.type.symbol.to_escaped_ascii) )
       |            endIf
       |          case ParserOpcode.RETURN
       |            if (call_stack.is_empty) return
       |            ip = call_stack.remove_last
       |            method_stack.remove_last
       |            cur_token = token_stack.remove_last
       |            vars.discard_from( var_frames.remove_last )
       |            nextIteration
       |          case ParserOpcode.CALL
       |            call_stack.add( ip+1 )
       |            token_stack.add( cur_token )
       |            ip = code[ ip ]
       |            method_stack.add( ip )
       |            var_frames.add( vars.count )
       |            nextIteration
       |          case ParserOpcode.JUMP
       |            ip = code[ ip ]
       |            nextIteration
       |          case ParserOpcode.JUMP_IF_TRUE
       |            if (number_stack.count and number_stack.remove_last) ip = code[ ip ]
       |            else                                                 ++ip
       |            nextIteration
       |          case ParserOpcode.JUMP_IF_FALSE
       |            if (number_stack.count and 0 == number_stack.remove_last) ip = code[ ip ]
       |            else                                                      ++ip
       |            nextIteration
       |          case ParserOpcode.ON_TOKEN_TYPE
       |            if (code[ip] == next_token_type)
       |              ip += 2
       |              cur_token = read
       |            else
       |              ip = code[ ip+1 ]
       |            endIf
       |            nextIteration
       |          case ParserOpcode.HAS_ANOTHER
       |            number_stack.add( next_token_type != -1 )
       |            nextIteration
       |          case ParserOpcode.NEXT_HAS_ATTRIBUTE
       |            number_stack.add( next_token_type != -1 and (TokenType(next_token_type).attributes & code[ip]) )
       |            ++ip
       |            nextIteration
       |          case ParserOpcode.NEXT_IS_TYPE
       |            number_stack.add( next_token_type == code[ip] )
       |            ++ip
       |            nextIteration
       |          case ParserOpcode.BEGIN_LIST
       |            list_start_t.add( peek )
       |            list_start_pos.add( cmd_queue.count )
       |            nextIteration
       |          case ParserOpcode.CREATE_CMD
       |            local cmd_type_index = code[ ip ]
       |            local arg_count = code[ ip+1 ]
       |            ip += 2
       |            cmd_args.clear
       |            if (arg_count > 0)
       |              local i1 = cmd_queue.count - arg_count
       |              if (i1 < 0)
       |                throw cur_token.error( "[INTERNAL] Command queue too small." )
       |              endIf
       |              cmd_args.add( forEach in cmd_queue from i1 )
       |              cmd_queue.discard_from( i1 )
       |            endIf
       |            cmd_queue.add( CmdFactory.create_cmd(cmd_type_index,cur_token,cmd_args) )
       |            nextIteration
       |
       |          case ParserOpcode.CREATE_NULL_CMD
       |            cmd_queue.add( null )
       |            nextIteration
       |
       |          case ParserOpcode.CREATE_LIST
       |            if (list_start_t.is_empty) throw peek.error( "[INTERNAL] No prior beginList before calling createList/produceList." )
       |            local t  = list_start_t.remove_last
       |            local i1 = list_start_pos.remove_last
       |            cmd_args.clear
       |            cmd_args.add( forEach in cmd_queue from i1 )
       |            cmd_queue.discard_from( i1 )
       |            cmd_queue.add( CmdList(t,cmd_args) )
       |            nextIteration
       |
       |          case ParserOpcode.CREATE_STATEMENTS
       |            if (list_start_t.is_empty) throw peek.error( "[INTERNAL] No prior beginList before calling createStatements/produceStatements." )
       |            local t  = list_start_t.remove_last
       |            local i1 = list_start_pos.remove_last
       |            cmd_args.clear
       |            cmd_args.add( forEach in cmd_queue from i1 )
       |            cmd_queue.discard_from( i1 )
       |            cmd_queue.add( CmdStatements(t,cmd_args) )
       |            nextIteration
       |
       |          case ParserOpcode.CONSUME_EOLS
       |            # Called to automatically consume EOL tokens that occur in the
       |            # midst of parsing a unary or binary operator, like "a+\nb".
       |            <handle_consume_eols>
       |            nextIteration
       |
       |          case ParserOpcode.CONSUME_TYPE
       |            if (next_token_type == code[ip])
       |              read
       |              number_stack.add( 1 )
       |            else
       |              number_stack.add( 0 )
       |            endIf
       |            ++ip
       |            nextIteration
       |
       |          case ParserOpcode.MUST_CONSUME_TYPE
       |            if (next_token_type == code[ip])
       |              read
       |              ++ip
       |              nextIteration
       |            else
       |              throw peek.error( "Expected '$', found $."(TokenType(code[ip]).symbol,?:{next_token_type!=-1:"'$'"(peek->String) || "end of input"}) )
       |            endIf
       |
       |          case ParserOpcode.SAVE_POSITION
       |            saved_positions.add( ParsePosition(position,cmd_queue.count,cur_token) )
       |            nextIteration
       |
       |          case ParserOpcode.RESTORE_POSITION
       |            if (saved_positions.is_empty) throw peek.error( "[INTERNAL] No savePosition to restore." )
       |            local pos = saved_positions.remove_last
       |            position = pos.position
       |            cmd_queue.discard_from( pos.cmd_count )
       |            cur_token = pos.cur_token
       |            if (position < tokens.count) next_token_type = tokens[position].type->Int32
       |            else                         next_token_type = -1
       |            nextIteration
       |
       |          case ParserOpcode.DISCARD_SAVED_POSITION
       |            if (saved_positions.count) saved_positions.remove_last
       |            nextIteration
       |
       |          case ParserOpcode.TRACE
       |            print( "Line " ).print( code[ip] ).print( " next:" )
       |            if (next_token_type != -1) print( peek )
       |            else                       print( "end of input" )
       |            ++ip
       |            print( " opcode:" ).print( ParserOpcode(code[ip]) )
       |            println
       |            print "  "
       |            forEach (m_ip at index in method_stack)
       |              if (index > 0) print " > "
       |              print methods_by_address[ m_ip ]
       |            endForEach
       |            println
       |            print "  ["
       |            forEach (cmd at index in cmd_queue)
       |              if (index > 0) print ","
       |              print select{ cmd:cmd.type_name || "null" }
       |            endForEach
       |            println "]"
       |            nextIteration
       |
       |          case ParserOpcode.PRINTLN_STRING
       |            println strings[ code[ip] ]
       |            ++ip
       |            nextIteration
       |
       |          case ParserOpcode.PRINTLN_NUMBER
       |            local value = number_stack.remove_last
       |            if (value == value.floor) println value->Int32
       |            else                      println value.format(".4")
       |            nextIteration
       |
       |          case ParserOpcode.POP_DISCARD
       |            number_stack.remove_last
       |            nextIteration
       |
       |          case ParserOpcode.PUSH_INT32
       |            number_stack.add( code[ip] )
       |            ++ip
       |            nextIteration
       |
       |          case ParserOpcode.DECLARE_VAR
       |            local name = strings[ code[ip] ]
       |            ++ip
       |            local index = locate_var( name, var_frames.last )
       |            if (index.exists)
       |              throw Error( "A variable named '$' has already been declared in the current method."(name) )
       |            else
       |              vars.add( Variable(name,number_stack.remove_last) )
       |            endIf
       |            nextIteration
       |
       |          case ParserOpcode.WRITE_VAR
       |            local name = strings[ code[ip] ]
       |            ++ip
       |            local index = locate_var( name, 0, &must_locate ).value
       |            vars[ index ] = Variable( name, number_stack.remove_last )
       |            nextIteration
       |
       |          case ParserOpcode.READ_VAR
       |            local name = strings[ code[ip] ]
       |            ++ip
       |            local index = locate_var( name, 0, &must_locate ).value
       |            number_stack.add( vars[index].value )
       |            nextIteration
       |
       |          case ParserOpcode.LOGICAL_NOT
       |            number_stack.last = not number_stack.last
       |            nextIteration
       |
       |          case ParserOpcode.COMPARE_EQ
       |            local b = number_stack.remove_last
       |            number_stack.add( number_stack.remove_last == b )
       |            nextIteration
       |
       |          case ParserOpcode.COMPARE_NE
       |            local b = number_stack.remove_last
       |            number_stack.add( number_stack.remove_last != b )
       |            nextIteration
       |
       |          case ParserOpcode.COMPARE_LT
       |            local b = number_stack.remove_last
       |            number_stack.add( number_stack.remove_last < b )
       |            nextIteration
       |
       |          case ParserOpcode.COMPARE_LE
       |            local b = number_stack.remove_last
       |            number_stack.add( number_stack.remove_last <= b )
       |            nextIteration
       |
       |          case ParserOpcode.COMPARE_GT
       |            local b = number_stack.remove_last
       |            number_stack.add( number_stack.remove_last > b )
       |            nextIteration
       |
       |          case ParserOpcode.COMPARE_GE
       |            local b = number_stack.remove_last
       |            number_stack.add( number_stack.remove_last >= b )
       |            nextIteration
       |
       |          others
       |            throw Error( "[INTERNAL]", "Unhandled parser opcode: " + ParserOpcode(opcode) )
       |        endWhich
       |      endLoop
       |
       |    method has_another->Logical
       |      return (position < tokens.count)
       |
       |    method load( data:Byte[] )
       |      load( DataReader(data) )
       |
       |    method load( reader:DataReader )
       |      local version = reader.read_int32x
       |      require version >= MIN_VERSION
       |      local n = reader.read_int32x
       |
       |      strings.reserve( n )
       |      loop (n) strings.add( reader.read_string )
       |
       |      # Method names & addresses
       |      n = reader.read_int32x
       |      methods.reserve( n )
       |      loop (n)
       |        local name = strings[ reader.read_int32x ]
       |        methods[ name ] = reader.read_int32x
       |        methods_by_address[ methods[name] ] = name
       |      endLoop
       |
       |      n = reader.read_int32x
       |      code.reserve( n )
       |      loop (n) code.add( reader.read_int32x )
       |
       |    method locate_var( name:String, lowest_index:Int32, &must_locate )->Int32?
       |      forEach (index in vars.count-1 downTo lowest_index)
       |        if (vars[index].name == name) return index
       |      endForEach
       |      if (must_locate) throw Error( "No variable named '$' has been declared."(name) )
       |      return null
       |
       |    method parse( rule_name:String )->Cmd
       |      local index = methods.locate( rule_name )
       |      if (not index.exists) throw Error( "[INTERNAL]", "No parse rule '$' exists."(rule_name) )
       |      return parse( methods[index.value] )
       |
       |    method parse( address:Int32 )->Cmd
       |      call_stack.clear
       |      cmd_queue.clear
       |      execute( address )
       |      if (cmd_queue.count) return cmd_queue.remove_last
       |      else                 return null
       |
       |    method peek->Token
       |      if (position == tokens.count)
       |        if (tokens.is_empty) return Token( filepath, "", 0, 0, TokenType(0) )
       |        local t = tokens.last.cloned( TokenType.EOI )
       |        ++t.column
       |        return t
       |      else
       |        return tokens[ position ]
       |      endIf
       |
       |    method read->Token
       |      ++position
       |      if (position < tokens.count) next_token_type = tokens[position].type->Int32
       |      else                         next_token_type = -1
       |      return tokens[ position-1 ]
       |
       |    method open( filepath, content:String, start_line=1:Int32, start_column=1:Int32 )
       |      require tokenizer
       |      open( filepath, tokenizer.tokenize(filepath,content,start_line,start_column) )
       |
       |    method open( file:File )
       |      require tokenizer
       |      open( file.filepath, tokenizer.tokenize(file) )
       |
       |    method open( filepath, tokens:Token[] )
       |      @tokens.clear
       |      @tokens.add( tokens )
       |      if (tokens.count)
       |        next_token_type = tokens.first.type->Int32
       |      else
       |        next_token_type = -1
       |      endIf
       |      position = 0
       |      cur_token = null
       |
       |
       |endClass
       |
       |class Variable( name:String, value:Real64 ) [compound]
       |endClass
       |
       |class ParsePosition( position:Int32, cmd_count:Int32, cur_token:Token ) [compound]
       |endClass
       |
endAugment

