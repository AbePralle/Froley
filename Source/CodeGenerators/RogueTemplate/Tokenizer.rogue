augment RogueTemplate
  PROPERTIES
    tokenizer =
      @|module FroleyLanguage
       |
       |$include "Code.rogue"
       |$include "Error.rogue"
       |$include "Token.rogue"
       |$include "TokenType.rogue"
       |$include "TokenizerOpcode.rogue"
       |
       |class Tokenizer
       |  DEFINITIONS
       |    VERSION     = 1
       |    MIN_VERSION = 1
       |
       |  PROPERTIES
       |    code         = Int32[]
       |    stack        = Int32[]
       |    strings      = String[]
       |    entry_points = EntryPoint[]
       |    ch           : Int32
       |    count        : Int32
       |    result       : Int32
       |    buffer       = StringBuilder()
       |    work_buffer  = StringBuilder()  # used for bufferToLowercase
       |    tokens       = Token[](1024)
       |
       |    filepath : String
       |    scanner  : Scanner
       |
       |    line   : Int32
       |    column : Int32
       |
       |    start_ip = 0
       |
       |    id_start      = "<id_start>"
       |    id_continue   = "<id_continue>"
       |    id_characters = Array<<Int32>>(128)
       |
       |  METHODS
       |    method init
       |      forEach (ch in id_continue) id_characters[ch->Int32] = 2
       |      forEach (ch in id_start)    id_characters[ch->Int32] = 1
       |      load( Code.tokenizer_code )
       |
       |    method reset
       |      stack.clear
       |      ch = 0
       |      count = 0
       |      result = 0
       |      buffer.clear
       |      start_ip = 0
       |      tokens.clear
       |
       |    method add( token_type:Int32 )
       |      local t = Token( TokenType(token_type), filepath, scanner.source, line, column )
       |      if (t.type.attributes & TokenTypeAttribute.CONTENT) t.content = buffer->String
       |      tokens.add( t )
       |
       |    method execute
       |      local ip = start_ip
       |      loop
       |        local opcode = TokenizerOpcode( code[ip] )
       |        #println "$ $" (ip.format("04"),opcode)
       |        ++ip
       |        which (opcode)
       |          case TokenizerOpcode.HALT
       |            return
       |          case TokenizerOpcode.RESTART
       |            buffer.clear
       |            ip = start_ip
       |            nextIteration
       |          case TokenizerOpcode.MODE_INT32
       |            start_ip = code[ ip ]
       |            ++ip
       |            nextIteration
       |          case TokenizerOpcode.SYNTAX_ERROR
       |            local builder = StringBuilder()
       |            builder.print "Syntax error - unexpected "
       |            if (not scanner.has_another)
       |              builder.println "end of input."
       |            else
       |              local c = scanner.peek
       |              if (c == 10 or c == 13)
       |                builder.println "end of line."
       |              elseIf (c == '\'')
       |                builder.println ''"'".''
       |              elseIf (c >= 32 and c != 127)
       |                builder.println "'$'." (c)
       |              else
       |                builder.println "'$'." (c.to_escaped_ascii)
       |              endIf
       |            endIf
       |            throw Error( filepath, scanner.source, scanner.line, scanner.column, builder->String )
       |          case TokenizerOpcode.BUFFER_ERROR
       |            throw Error( filepath, scanner.source, scanner.line, scanner.column, buffer->String )
       |          case TokenizerOpcode.MARK_SOURCE_POS
       |            line   = scanner.line
       |            column = scanner.column
       |            nextIteration
       |          case TokenizerOpcode.CREATE_INT32
       |            local token_type = code[ ip ]
       |            ++ip
       |            add( token_type )
       |            buffer.clear
       |            nextIteration
       |          case TokenizerOpcode.JUMP
       |            ip = code[ ip ]
       |            nextIteration
       |          case TokenizerOpcode.JUMP_EQ
       |            if (result == 0) ip = code[ ip ]
       |            else             ++ip
       |            nextIteration
       |          case TokenizerOpcode.JUMP_NE
       |            if (result != 0) ip = code[ ip ]
       |            else             ++ip
       |            nextIteration
       |          case TokenizerOpcode.JUMP_LT
       |            if (result < 0) ip = code[ ip ]
       |            else            ++ip
       |            nextIteration
       |          case TokenizerOpcode.JUMP_LE
       |            if (result <= 0) ip = code[ ip ]
       |            else             ++ip
       |            nextIteration
       |          case TokenizerOpcode.JUMP_GT
       |            if (result > 0) ip = code[ ip ]
       |            else            ++ip
       |            nextIteration
       |          case TokenizerOpcode.JUMP_GE
       |            if (result >= 0) ip = code[ ip ]
       |            else             ++ip
       |            nextIteration
       |          case TokenizerOpcode.CALL
       |            stack.add( ip+1 )
       |            ip = code[ ip ]
       |            nextIteration
       |          case TokenizerOpcode.RETURN
       |            if (stack.is_empty) throw Error( "[Compiled Code]", "'return' on empty stack." )
       |            ip = stack.remove_last
       |            nextIteration
       |          case TokenizerOpcode.HAS_ANOTHER
       |            result = select{ scanner.has_another:1 || 0 }
       |            nextIteration
       |          case TokenizerOpcode.PEEK_CH_INT32
       |            ch = scanner.peek( code[ip] )
       |            ++ip
       |            nextIteration
       |          case TokenizerOpcode.PEEK_CH_COUNT
       |            ch = scanner.peek( count )
       |            nextIteration
       |          case TokenizerOpcode.READ_CH
       |            ch = scanner.read
       |            nextIteration
       |          case TokenizerOpcode.CONSUME_CHARACTER
       |            local value = code[ip]->Character
       |            result = select{ scanner.consume(value):1 || 0 }
       |            ++ip
       |            nextIteration
       |          case TokenizerOpcode.NEXT_IS_CHARACTER
       |            local value = code[ip]->Character
       |            result = (scanner.has_another and scanner.peek == value)
       |            ++ip
       |            nextIteration
       |          case TokenizerOpcode.SCAN_DIGITS
       |            local min_digits = code[ ip ]
       |            local max_digits = code[ ip+1 ]
       |            local base = code[ ip+2 ]
       |            ip += 3
       |            ch = 0
       |            local n = 0
       |            loop (max_digits)
       |              if (scanner.has_another and scanner.peek.is_number(base))
       |                ch = ch * base + scanner.read.to_number(base)
       |                ++n
       |              else
       |                escapeLoop
       |              endIf
       |            endLoop
       |            result = n - min_digits
       |            nextIteration
       |          case TokenizerOpcode.SCAN_IDENTIFIER
       |            if (scanner.has_another and id_characters[scanner.peek&0x7F] == 1)
       |              buffer.clear
       |              buffer.print( scanner.read )
       |              while (scanner.has_another and id_characters[scanner.peek&0x7f])
       |                buffer.print( scanner.read )
       |              endWhile
       |              result = 1
       |            else
       |              result = 0
       |            endIf
       |            nextIteration
       |          case TokenizerOpcode.CLEAR_BUFFER
       |            buffer.clear
       |            nextIteration
       |          case TokenizerOpcode.COLLECT_CH
       |            buffer.print( ch->Character )
       |            nextIteration
       |          case TokenizerOpcode.COLLECT_CHARACTER
       |            buffer.print( code[ip]->Character )
       |            ++ip
       |            nextIteration
       |          case TokenizerOpcode.COLLECT_STRING
       |            buffer.print( strings[code[ip]] )
       |            ++ip
       |            nextIteration
       |          case TokenizerOpcode.BUFFER_TO_LOWERCASE
       |            work_buffer.clear
       |            work_buffer.print( (forEach in buffer).to_lowercase )
       |            buffer.clear.print( work_buffer )
       |            nextIteration
       |          case TokenizerOpcode.PRINT_BUFFER
       |            print (forEach in buffer)
       |            nextIteration
       |          case TokenizerOpcode.PRINT_CH
       |            print ch->Character
       |            nextIteration
       |          case TokenizerOpcode.PRINT_COUNT
       |            print count
       |            nextIteration
       |          case TokenizerOpcode.PRINT_CHARACTER
       |            print code[ip]->Character
       |            ++ip
       |            nextIteration
       |          case TokenizerOpcode.PRINT_STRING
       |            print strings[ code[ip] ]
       |            ++ip
       |            nextIteration
       |          case TokenizerOpcode.COMPARE_CH_INT32
       |            result = ch - code[ip]
       |            ++ip
       |            nextIteration
       |          case TokenizerOpcode.COMPARE_COUNT_INT32
       |            result = count - code[ip]
       |            ++ip
       |            nextIteration
       |          case TokenizerOpcode.CH_IS_DIGIT_INT32
       |            local base = code[ip]
       |            ++ip
       |            local n = (ch->Character).to_number( base )
       |            result = select{ (n>=0 and n<base):1 || 0 }
       |            nextIteration
       |          case TokenizerOpcode.CH_IS_DIGIT_COUNT
       |            local n = (ch->Character).to_number( count )
       |            result = select{ (n>=0 and n<count):1 || 0 }
       |            nextIteration
       |          case TokenizerOpcode.CH_IS_LETTER
       |            result = select{ ((ch>='a' and ch<='z') or (ch>='A' and ch<='Z')):1 || 0 }
       |            nextIteration
       |          case TokenizerOpcode.PUSH_CH
       |            stack.add( ch )
       |            nextIteration
       |          case TokenizerOpcode.PUSH_COUNT
       |            stack.add( count )
       |            nextIteration
       |          case TokenizerOpcode.POP_CH
       |            if (stack.is_empty) throw Error( "[Compiled Code]", "'pop ch' on empty stack." )
       |            ch = stack.remove_last
       |            nextIteration
       |          case TokenizerOpcode.POP_COUNT
       |            if (stack.is_empty) throw Error( "[Compiled Code]", "'pop count' on empty stack." )
       |            count = stack.remove_last
       |            nextIteration
       |          case TokenizerOpcode.SET_CH_TO_INT32
       |            ch = code[ ip ]
       |            result = ch
       |            ++ip
       |            nextIteration
       |          case TokenizerOpcode.SET_CH_TO_COUNT
       |            ch = count
       |            result = ch
       |            nextIteration
       |          case TokenizerOpcode.SET_COUNT_TO_INT32
       |            count = code[ ip ]
       |            result = count
       |            ++ip
       |            nextIteration
       |          case TokenizerOpcode.SET_COUNT_TO_CH
       |            count = ch
       |            result = count
       |            nextIteration
       |          case TokenizerOpcode.SET_RESULT_TO_CH
       |            result = ch
       |            nextIteration
       |          case TokenizerOpcode.SET_RESULT_TO_COUNT
       |            result = count
       |            nextIteration
       |          case TokenizerOpcode.SET_RESULT_TO_INT32
       |            result = code[ ip ]
       |            ++ip
       |            nextIteration
       |          case TokenizerOpcode.ADD_CH_COUNT
       |            ch += count
       |            nextIteration
       |          case TokenizerOpcode.ADD_CH_INT32
       |            ch += code[ ip ]
       |            ++ip
       |            nextIteration
       |          case TokenizerOpcode.ADD_COUNT_INT32
       |            count += code[ ip ]
       |            ++ip
       |            nextIteration
       |          case TokenizerOpcode.SUBTRACT_CH_COUNT
       |            ch -= count
       |            nextIteration
       |          case TokenizerOpcode.WHICH_INPUT
       |            local cur_node = ip
       |            local lookahead = 0
       |            local last_acceptable_node = 0
       |            local last_acceptable_link_count = 0
       |            local last_acceptable_lookahead = 0
       |            loop
       |              local link_count = code[cur_node+1]
       |              if (code[cur_node])
       |                last_acceptable_node = cur_node
       |                last_acceptable_link_count = link_count
       |                last_acceptable_lookahead = lookahead
       |              endIf
       |              if (not scanner.has_another(lookahead+1)) escapeLoop
       |              local c = scanner.peek( lookahead )
       |              ip = cur_node + 2
       |              contingent
       |                loop (link_count)
       |                  if (c == code[ip])
       |                    cur_node = code[ ip+1 ]
       |                    sufficient true
       |                  endIf
       |                  ip += 2
       |                endLoop
       |                escapeLoop
       |              satisfied
       |                ++lookahead
       |              endContingent
       |            endLoop
       |            # Either no links match or EOI - jump to code of last acceptable node.
       |            # The start node is always acceptable and either contains the
       |            # 'others' case or jumps to the end of the scan table.
       |            ip = last_acceptable_node + last_acceptable_link_count * 2 + 2
       |            loop (last_acceptable_lookahead) buffer.print( scanner.read )
       |            nextIteration
       |
       |          case TokenizerOpcode.WHICH_BUFFER
       |            local cur_node = ip
       |            local start_node = cur_node
       |            local lookahead = 0
       |            loop
       |              local link_count = code[cur_node+1]
       |              if (lookahead == buffer.count) escapeLoop
       |              local c = buffer[ lookahead ]
       |              ip = cur_node + 2
       |              contingent
       |                loop (link_count)
       |                  if (c == code[ip])
       |                    cur_node = code[ ip+1 ]
       |                    sufficient true
       |                  endIf
       |                  ip += 2
       |                endLoop
       |                escapeLoop
       |              satisfied
       |                ++lookahead
       |              endContingent
       |            endLoop
       |
       |            # Either no links match or EOI
       |            if (code[cur_node] == 0 or lookahead < buffer.count)
       |              # Not a complete match; use the 'others' code in the start node
       |              cur_node = start_node
       |            endIf
       |            ip = cur_node + code[cur_node+1] * 2 + 2
       |            nextIteration
       |          others
       |            throw Error( "[INTERNAL]", "Unhandled tokenizer opcode: " + TokenizerOpcode(opcode) )
       |        endWhich
       |      endLoop
       |
       |    method load( data:Byte[] )
       |      load( DataReader(data) )
       |
       |    method load( reader:DataReader )
       |      local version = reader.read_int32x
       |      require version >= MIN_VERSION
       |      local n = reader.read_int32x
       |      strings.reserve( n )
       |      loop (n) strings.add( reader.read_string )
       |
       |      n = reader.read_int32x
       |      entry_points.reserve( n )
       |      loop (n)
       |        local name = strings[ reader.read_int32x ]
       |        entry_points.add( EntryPoint(name,reader.read_int32x) )
       |      endLoop
       |
       |      n = reader.read_int32x
       |      code.reserve( n )
       |      loop (n) code.add( reader.read_int32x )
       |
       |    method tokenize( file:File )->Token[]
       |      if (not file.exists) throw Error( "File not found: $." (file.filepath) )
       |      tokenize( file.filepath, file.load_as_string )
       |      return tokens
       |
       |    method tokenize( filepath, source:String, start_line=1:Int32, start_column=1:Int32 )->Token[]
       |      reset
       |      scanner = Scanner( source )
       |      scanner.line = start_line
       |      scanner.column = start_column
       |      execute
       |      return tokens
       |endClass
       |
       |class EntryPoint( name:String, ip:Int32 ) [compound]
       |  METHODS
       |    method to->String
       |      return "$ $" (ip.format("04"),name)
       |endClass
       |
endAugment

