module Froley
  uses ParseKit<<Froley>>

class VM
  DEFINITIONS
    VERSION     = 1
    MIN_VERSION = 1

  PROPERTIES
    code         = Int32[]
    stack        = Int32[]
    strings      = String[]
    entry_points = EntryPoint[]
    ch           : Int32
    count        : Int32
    result       : Int32
    buffer       = StringBuilder()

    filepath : String
    scanner  : Scanner

    next_line   : Int32
    next_column : Int32

    start_ip = 0

    id_begin_letter : Logical
    id_begin_digit  : Logical
    id_begin_other  = ""

    id_continue_letter : Logical
    id_continue_digit  : Logical
    id_continue_other  = ""

  METHODS
    method init( data:Byte[] )
      load( data )

    method accept( token_type:Int32 )
      #println "Accepting $ ($)" (token_type,buffer->String.to_escaped_ascii)
      println "Accepting $ ($)" (Froley.token_def(token_type).name,buffer->String.to_escaped_ascii)

    method execute
      local ip = start_ip
      loop
        local opcode = code[ ip ]
        #println "$ $" (ip.format("03"),Opcode(opcode))
        ++ip
        which (opcode)
          case Opcode.HALT
            return
          case Opcode.RESTART
            buffer.clear
            ip = start_ip
            nextIteration
          case Opcode.MODE_INT32
            start_ip = code[ ip ]
            ++ip
            nextIteration
          case Opcode.ERROR
            throw FroleyError( filepath, scanner.source, scanner.line, scanner.column, buffer->String )
          case Opcode.RETURN
            if (stack.is_empty) throw FroleyError( "[Compiled Code]", "'return' on empty stack." )
            ip = stack.remove_last
            nextIteration
          case Opcode.ACCEPT_INT32
            local token_type = code[ ip ]
            ip = start_ip
            accept( token_type )
            buffer.clear
          case Opcode.JUMP
            ip = code[ ip ]
            nextIteration
          case Opcode.JUMP_EQ
            if (result == 0) ip = code[ ip ]
            else             ++ip
            nextIteration
          case Opcode.JUMP_NE
            if (result != 0) ip = code[ ip ]
            else             ++ip
            nextIteration
          case Opcode.JUMP_LT
            if (result < 0) ip = code[ ip ]
            else            ++ip
            nextIteration
          case Opcode.JUMP_LE
            if (result <= 0) ip = code[ ip ]
            else             ++ip
            nextIteration
          case Opcode.JUMP_GT
            if (result > 0) ip = code[ ip ]
            else            ++ip
            nextIteration
          case Opcode.JUMP_GE
            if (result >= 0) ip = code[ ip ]
            else             ++ip
            nextIteration
          case Opcode.CALL
            ++ip
            stack.add( ip )
            ip = code[ ip-1 ]
            nextIteration
          case Opcode.MARK_SOURCE_POS
            next_line = scanner.line
            next_column = scanner.column
            nextIteration
          case Opcode.HAS_ANOTHER
            result = select{ scanner.has_another:1 || 0 }
            nextIteration
          case Opcode.READ_CH
            ch = scanner.read
            nextIteration
          case Opcode.PEEK_CH_INT32
#trace "peek " + code[ip]
            ch = scanner.peek( code[ip] )
#trace ch->Character
            ++ip
            nextIteration
          case Opcode.PEEK_CH_COUNT
            ch = scanner.peek( count )
            nextIteration
          case Opcode.CONSUME_CHARACTER
            local value = code[ip]->Character
            result = select{ scanner.consume(value):1 || 0 }
            ++ip
            nextIteration
          case Opcode.SCAN_DIGITS
            local min_digits = code[ ip ]
            local max_digits = code[ ip+1 ]
            local base = code[ ip+2 ]
            ip += 3
            ch = 0
            local n = 0
            loop (max_digits)
              if (scanner.has_another and scanner.peek.is_number(base))
                ch = ch * base + scanner.read.to_number(base)
                ++n
              else
                escapeLoop
              endIf
            endLoop
            result = n - min_digits
            nextIteration
          case Opcode.CLEAR_BUFFER
            buffer.clear
            nextIteration
          case Opcode.COLLECT_CH
            buffer.print( ch->Character )
            nextIteration
          case Opcode.COLLECT_CHARACTER
            buffer.print( code[ip]->Character )
            ++ip
            nextIteration
          case Opcode.COLLECT_STRING
            buffer.print( strings[code[ip]] )
            ++ip
            nextIteration
          case Opcode.PRINT_BUFFER
            print (forEach in buffer)
            nextIteration
          case Opcode.PRINT_CH
            print ch->Character
            nextIteration
          case Opcode.PRINT_COUNT
            print count
            nextIteration
          case Opcode.PRINT_CHARACTER
            print code[ip]->Character
            ++ip
            nextIteration
          case Opcode.PRINT_STRING
            print strings[ code[ip] ]
            ++ip
            nextIteration
          case Opcode.COMPARE_CH_INT32
            result = ch - code[ip]
            ++ip
            nextIteration
          case Opcode.COMPARE_COUNT_INT32
            result = count - code[ip]
            ++ip
            nextIteration
          case Opcode.TEST_CH
            result = ch
            nextIteration
          case Opcode.TEST_COUNT
            result = count
            nextIteration
          case Opcode.PUSH_CH
            stack.add( ch )
            nextIteration
          case Opcode.POP_CH
            if (stack.is_empty) throw FroleyError( "[Compiled Code]", "'pop ch' on empty stack." )
            ch = stack.remove_last
            nextIteration
          case Opcode.PUSH_COUNT
            stack.add( count )
            nextIteration
          case Opcode.POP_COUNT
            if (stack.is_empty) throw FroleyError( "[Compiled Code]", "'pop count' on empty stack." )
            count = stack.remove_last
            nextIteration
          case Opcode.SET_CH_TO_INT32
            ch = code[ ip ]
            result = ch
            ++ip
            nextIteration
          case Opcode.SET_CH_TO_COUNT
            ch = count
            result = ch
            nextIteration
          case Opcode.SET_COUNT_TO_INT32
            count = code[ ip ]
            result = count
            ++ip
            nextIteration
          case Opcode.SET_COUNT_TO_CH
            count = ch
            result = count
            nextIteration
          case Opcode.ADD_CH_INT32
            ch += code[ ip ]
            ++ip
            nextIteration
          case Opcode.ADD_COUNT_INT32
            count += code[ ip ]
            ++ip
            nextIteration
          case Opcode.SCAN_TABLE
            local cur_node = ip
            local lookahead = 0
            local last_acceptable_node = 0
            local last_acceptable_link_count = 0
            local last_acceptable_lookahead = 0
            loop
              local link_count = code[cur_node+1]
              if (code[cur_node])
                last_acceptable_node = cur_node
                last_acceptable_link_count = link_count
                last_acceptable_lookahead = lookahead
              endIf
              if (not scanner.has_another(lookahead+1)) escapeLoop
              local c = scanner.peek( lookahead )
              ip = cur_node + 2
              contingent
                loop (link_count)
                  if (c == code[ip])
                    cur_node = code[ ip+1 ]
                    sufficient true
                  endIf
                  ip += 2
                endLoop
                local on_letter = code[ip]
                if (on_letter and ((c>='a' and c<='z') or (c>='A' and c<='Z')))
                  cur_node = on_letter
                  sufficient true
                endIf
                local on_digit = code[ip+1]
                if (on_digit and c>='0' and c<='9')
                  cur_node = on_digit
                  sufficient true
                endIf
                escapeLoop
              satisfied
                ++lookahead
              endContingent
            endLoop
            # Either no links match or EOI - jump to code of last acceptable node.
            # The start node is always acceptable and either contains the
            # 'others' case or jumps to the end of the scan table.
            ip = last_acceptable_node + last_acceptable_link_count * 2 + 4
            loop (last_acceptable_lookahead) buffer.print( scanner.read )
            nextIteration
          others
            throw FroleyError( "[INTERNAL] Unhandled opcode: " + Opcode(opcode) )
        endWhich
      endLoop

    method load( data:Byte[] )
      load( DataReader(data) )

    method load( reader:DataReader )
      local version = reader.read_int32x
      require version >= MIN_VERSION
      local n = reader.read_int32x
      strings.reserve( n )
      loop (n) strings.add( reader.read_string )

      n = reader.read_int32x
      entry_points.reserve( n )
      loop (n)
        local name = strings[ reader.read_int32x ]
        entry_points.add( EntryPoint(name,reader.read_int32x) )
      endLoop

      n = reader.read_int32x
      code.reserve( n )
      loop (n) code.add( reader.read_int32x )

    method tokenize( file:File )
      if (not file.exists) throw FroleyError( "File not found: $." (file.filepath) )
      tokenize( file.filepath, file.load_as_string )

    method tokenize( filepath, source:String )
      scanner = Scanner( source )
      execute
endClass

class EntryPoint( name:String, ip:Int32 ) [compound]
  METHODS
    method to->String
      return "$ $" (ip.format("04"),name)
endClass

