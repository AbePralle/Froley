module Froley
  uses ParseKit<<Froley>>

class PatternGraphBuilder
  PROPERTIES
    end_state          : ScanState
    patterns           = Pattern[]

  METHODS
    method init( end_state )

    method init( pattern:Pattern, end_state )
      patterns.add( pattern )

    method apply( cur_state:ScanState )
      if (patterns.count)
        patterns.remove_first.apply( this, cur_state )
      elseIf (cur_state is not end_state)
        if (cur_state.statements.is_empty)
          if (end_state.is_redirected)
            cur_state.statements.add( CmdGotoLabel(end_state.statements.first.t,end_state.code_label) )
          else
            # The original end state may never be defined, so we'll have this state take
            # over the end state duties and redirect other accept states here.
            cur_state.is_acceptable = true
            end_state.is_redirected = true
            end_state.code_label = cur_state.code_label
            cur_state.statements.add( end_state.statements )
            if (cur_state.statements.count)
              end_state.statements.clear
              end_state.statements.add( CmdGotoLabel(cur_state.statements.first.t,cur_state.code_label) )
            endIf
          endIf

          if (end_state.statements.count)
            cur_state.is_acceptable = true
          endIf
        endIf
      endIf

    method cloned->PatternGraphBuilder
      return cloned( end_state )

    method cloned( new_end_state:ScanState )->PatternGraphBuilder
      local result = PatternGraphBuilder( new_end_state )
      result.patterns.add( patterns )
      return result

    method has_another->Logical
      return patterns.count

    method push( pattern:Pattern )
      patterns.insert( pattern )

endClass

class Pattern( t:Token )
  METHODS
    method apply( builder:PatternGraphBuilder, cur_state:ScanState )
      throw UnsupportedOperationError()

    method is_single_character->Logical
      throw UnsupportedOperationError()

    method make_repeating( cur_state:ScanState, builder:PatternGraphBuilder )
      throw UnsupportedOperationError()

endClass

class SequencePattern : Pattern
  PROPERTIES
    patterns = Pattern[]

  METHODS
    method add( pattern:Pattern )
      patterns.add( pattern )

    method apply( builder:PatternGraphBuilder, cur_state:ScanState )
      forEach (pattern in patterns step -1)
        builder.push( pattern )
      endForEach
      builder.apply( cur_state )

    method is_single_character->Logical
      if (patterns.count != 1) return false
      return patterns.first.is_single_character

    method make_repeating( cur_state:ScanState, builder:PatternGraphBuilder )
      if (cur_state.is_visited) return
      patterns.first.make_repeating( cur_state, builder )

    method to->String
      return "($)" (patterns.join(" "))
endClass

class OrPattern : Pattern
  PROPERTIES
    patterns = Pattern[]

  METHODS
    method add( pattern:Pattern )
      patterns.add( pattern )

    method apply( builder:PatternGraphBuilder, cur_state:ScanState )
      forEach (pattern in patterns)
        builder.cloned.[ push(pattern) ].apply( cur_state )
      endForEach

    method is_single_character->Logical
      if (not (forEach in patterns).is_single_character) return false
      return true

    method make_repeating( cur_state:ScanState, builder:PatternGraphBuilder )
      if (cur_state.is_visited) return
      forEach (pattern in patterns)
        pattern.make_repeating( cur_state, builder )
      endForEach

    method to->String
      return "($)" (patterns.join("|"))
endClass

class ZeroOrMorePattern( t, operand:Pattern ) : Pattern
  METHODS
    method apply( builder:PatternGraphBuilder, cur_state:ScanState )
      if (not operand.is_single_character)
        throw t.error( "Zero-or-more (*) can only be applied to single characters and groups of single-character alternatives." )
      endIf

      operand.make_repeating( cur_state, builder )

    method is_single_character->Logical
      return false

    method to->String
      return "($)*" (operand)
endClass

class LetterPattern : Pattern
  METHODS
    method apply( builder:PatternGraphBuilder, cur_state:ScanState )
      apply( builder, cur_state, forEach in 'a'..'z' )
      apply( builder, cur_state, forEach in 'A'..'Z' )
      if (cur_state.on_letter)
        builder.apply( cur_state.on_letter )
      elseIf (builder.has_another)
        cur_state.on_letter = ScanState()
        builder.apply( cur_state.on_letter )
      else
        cur_state.on_letter = builder.end_state
      endIf

    method apply( builder:PatternGraphBuilder, cur_state:ScanState, ch:Character )
      local new_state : ScanState
      if (cur_state.links.contains(ch))
        new_state = cur_state.link( ch )
        builder.cloned.apply( new_state )
      endIf

    method is_single_character->Logical
      return true

    method make_repeating( cur_state:ScanState, builder:PatternGraphBuilder )
      if (cur_state.is_visited) return
      cur_state.is_visited = true
      make_repeating( cur_state, builder, forEach in 'a'..'z' )
      make_repeating( cur_state, builder, forEach in 'A'..'Z' )
      if (cur_state.on_letter)
        if (not cur_state.is_loop_state)
          make_repeating( cur_state.on_letter, builder )
        endIf
      elseIf (cur_state.is_loop_state)
        cur_state.on_letter = cur_state
      else
        cur_state.on_letter = ScanState().[ is_loop_state=true ]
        make_repeating( cur_state.on_letter, builder )
      endIf
      builder.cloned.apply( cur_state )
      cur_state.is_visited = false

    method make_repeating( cur_state:ScanState, builder:PatternGraphBuilder, ch:Character )
      if (cur_state.links.contains(ch)) make_repeating( cur_state.links[ch], builder )

    method to->String
      return "letter"
endClass

class DigitPattern : Pattern
  METHODS
    method apply( builder:PatternGraphBuilder, cur_state:ScanState )
      apply( builder, cur_state, forEach in '0'..'9' )
      if (cur_state.on_digit)
        builder.apply( cur_state.on_digit )
      elseIf (builder.has_another)
        cur_state.on_digit = ScanState()
        builder.apply( cur_state.on_digit )
      else
        cur_state.on_digit = builder.end_state
      endIf

    method apply( builder:PatternGraphBuilder, cur_state:ScanState, ch:Character )
      local new_state : ScanState
      if (cur_state.links.contains(ch))
        new_state = cur_state.link( ch )
        builder.cloned.apply( new_state )
      endIf

    method is_single_character->Logical
      return true

    method make_repeating( cur_state:ScanState, builder:PatternGraphBuilder )
      if (cur_state.is_visited) return
      cur_state.is_visited = true

      make_repeating( cur_state, builder, forEach in '0'..'9' )
      if (cur_state.on_digit)
        if (not cur_state.is_loop_state)
          make_repeating( cur_state.on_digit, builder )
        endIf
      elseIf (cur_state.is_loop_state)
        cur_state.on_digit = cur_state
      else
        cur_state.on_digit = ScanState().[ is_loop_state=true ]
        make_repeating( cur_state.on_digit, builder )
      endIf

      builder.cloned.apply( cur_state )
      cur_state.is_visited = false

    method make_repeating( cur_state:ScanState, builder:PatternGraphBuilder, ch:Character )
      if (cur_state.links.contains(ch)) make_repeating( cur_state.links[ch], builder )

    method to->String
      return "digit"
endClass

class StringPattern( t, value:String ) : Pattern
endClass

class CharacterPattern( t, ch:Character ) : Pattern
  GLOBAL PROPERTIES
    instance : CharacterPattern

  METHODS
    method apply( builder:PatternGraphBuilder, cur_state:ScanState )
      local new_state : ScanState
      if (cur_state.links.contains(ch))
        new_state = cur_state.link( ch )
      elseIf (cur_state.on_letter and ((ch>='a' and ch<='z') or (ch>='A' and ch<='Z')))
        new_state = cur_state.on_letter.cloned
        cur_state.links[ ch ] = new_state
      elseIf (cur_state.on_digit and ch>='0' and ch<='9')
        new_state = cur_state.on_digit.cloned
        cur_state.links[ ch ] = new_state
      elseIf (builder.has_another)
        new_state = cur_state.link( ch )
      else
        new_state = builder.end_state
        cur_state.links[ ch ] = new_state
      endIf
      builder.apply( new_state )

    method is_single_character->Logical
      return true

    method make_repeating( cur_state:ScanState, builder:PatternGraphBuilder )
      if (cur_state.is_visited) return
      cur_state.is_visited = true

      if (cur_state.links.contains(ch))
        if (not cur_state.is_loop_state)
          make_repeating( cur_state.links[ch], builder )
        endIf
      elseIf (cur_state.is_loop_state)
        cur_state.links[ch] = cur_state
      else
        cur_state.links[ch] = ScanState().[ is_loop_state=true ]
        make_repeating( cur_state.links[ch], builder )
      endIf

      if (cur_state.on_letter and ((ch>='a' and ch<='z') or (ch>='A' and ch<='Z')))
        local new_state = cur_state.on_letter.cloned
        cur_state.links[ ch ] = new_state
        make_repeating( new_state, builder )
      elseIf (cur_state.on_digit and ch>='0' and ch<='9')
        local new_state = cur_state.on_letter.cloned
        cur_state.links[ ch ] = new_state
        make_repeating( new_state, builder )
      endIf

      builder.cloned.apply( cur_state )
      cur_state.is_visited = false

    method to->String
      return "'$'" (ch.to_escaped_ascii)
endClass

