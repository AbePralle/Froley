module Froley
  uses ParseKit<<Froley>>

class PatternGraphBuilder
  PROPERTIES
    end_state          : ScanState
    patterns           = Pattern[]

  METHODS
    method init( end_state )

    method init( pattern:Pattern, end_state )
      patterns.add( pattern )

    method apply( cur_state:ScanState )
      if (patterns.count)
        patterns.remove_first.apply( this, cur_state )
      elseIf (end_state and cur_state is not end_state)
        if (cur_state.statements.is_empty)
          if (end_state.is_redirected)
            cur_state.statements.add( CmdGotoLabel(end_state.statements.first.t,end_state.code_label) )
          else
            # The original end state may never be defined, so we'll have this state take
            # over the end state duties and redirect other accept states here.
            cur_state.is_acceptable = true
            end_state.is_redirected = true
            end_state.code_label = cur_state.code_label
            cur_state.statements.add( end_state.statements )
            if (cur_state.statements.count)
              end_state.statements.clear
              end_state.statements.add( CmdGotoLabel(cur_state.statements.first.t,cur_state.code_label) )
            endIf
          endIf

          if (end_state.statements.count)
          else
            cur_state.is_acceptable = true
          endIf
        endIf
      endIf

    method cloned->PatternGraphBuilder
      local result = PatternGraphBuilder( end_state )
      result.patterns.add( patterns )
      return result

    method has_another->Logical
      return patterns.count

    method push( pattern:Pattern )
      patterns.insert( pattern )

endClass

class PatternLoopMaker
  PROPERTIES
    patterns         = Pattern[]
    loop_start_state : ScanState

  METHODS
    method init
      noAction

    method init( pattern:Pattern, loop_start_state=null )
      patterns.add( pattern )

    method cloned->PatternLoopMaker
      local result = PatternLoopMaker()
      result.patterns.add( patterns )
      return result

    method apply( cur_state:ScanState )
      if (patterns.count)
        patterns.remove_first.apply( this, cur_state )
      endIf

    method push( pattern:Pattern )
      patterns.insert( pattern )

endClass

class Pattern( t:Token )
  METHODS
    method apply( builder:PatternGraphBuilder, cur_state:ScanState )
      throw UnsupportedOperationError()

    method apply( maker:PatternLoopMaker, cur_state:ScanState )
      throw UnsupportedOperationError()

endClass

class SequencePattern : Pattern
  PROPERTIES
    patterns = Pattern[]

  METHODS
    method add( pattern:Pattern )
      patterns.add( pattern )

    method apply( builder:PatternGraphBuilder, cur_state:ScanState )
      forEach (pattern in patterns step -1)
        builder.push( pattern )
      endForEach
      builder.apply( cur_state )

    method apply( maker:PatternLoopMaker, cur_state:ScanState )
      forEach (pattern in patterns step -1)
        maker.push( pattern )
      endForEach
      maker.apply( cur_state )

    method to->String
      return "($)" (patterns.join(" "))
endClass

class OrPattern : Pattern
  PROPERTIES
    patterns = Pattern[]

  METHODS
    method add( pattern:Pattern )
      patterns.add( pattern )

    method apply( builder:PatternGraphBuilder, cur_state:ScanState )
      forEach (pattern in patterns)
        builder.cloned.[ push(pattern) ].apply( cur_state )
      endForEach

      #{
    method apply( maker:PatternLoopMaker, cur_state:ScanState, loop_start_state:ScanState )
      forEach (pattern in patterns)
        builder.cloned.[ push(pattern) ].apply( cur_state, loop_start_state )
      endForEach
      }#

    method to->String
      return "($)" (patterns.join("|"))
endClass

class ZeroOrMorePattern( t, operand:Pattern ) : Pattern
  METHODS
    method apply( builder:PatternGraphBuilder, cur_state:ScanState )
      # Skip indefinite iterations during this phase
      builder.apply( cur_state )

      #method apply( maker:PatternLoopMaker, cur_state:ScanState, loop_start_state:ScanState )

    method to->String
      return "($)*" (operand)
endClass

class LetterPattern : Pattern
  METHODS
    method apply( builder:PatternGraphBuilder, cur_state:ScanState )
      apply( builder, cur_state, forEach in 'a'..'z' )
      apply( builder, cur_state, forEach in 'A'..'Z' )
      if (cur_state.on_letter)
        builder.apply( cur_state.on_letter )
      elseIf (builder.has_another)
        cur_state.on_letter = ScanState()
        builder.apply( cur_state.on_letter )
      elseIf (builder.end_state)
        cur_state.on_letter = builder.end_state
        # No end_state means we've reached the end of an indefinite repeat branch (e.g. letter*);
        # we'll leave this dead end for now and come back and fix it in the next pass.
      endIf

    method apply( builder:PatternGraphBuilder, cur_state:ScanState, ch:Character )
      local new_state : ScanState
      if (cur_state.links.contains(ch))
        new_state = cur_state.link( ch )
        builder.cloned.apply( new_state )
      endIf

      #{
    method apply( maker:PatternLoopMaker, cur_state:ScanState )
      apply( maker, cur_state, forEach in 'a'..'z' )
      apply( maker, cur_state, forEach in 'A'..'Z' )
      if (cur_state.on_letter)
        maker.apply( cur_state.on_letter )
      elseIf (not maker.has_another)
        cur_state.on_letter = ScanState()
        maker.apply( cur_state.on_letter )
      elseIf (maker.end_state)
        cur_state.on_letter = maker.end_state
        # No end_state means we've reached the end of an indefinite repeat branch (e.g. letter*);
        # we'll leave this dead end for now and come back and fix it in the next pass.
      endIf

    method apply( maker:PatternLoopMaker, cur_state:ScanState, ch:Character )
      local new_state : ScanState
      if (cur_state.links.contains(ch))
        new_state = cur_state.link( ch )
        maker.cloned.apply( new_state )
      endIf
      }#

    method to->String
      return "letter"
endClass

class DigitPattern : Pattern
  METHODS
    method apply( builder:PatternGraphBuilder, cur_state:ScanState )
      apply( builder, cur_state, forEach in '0'..'9' )
      if (cur_state.on_digit)
        builder.apply( cur_state.on_digit )
      elseIf (builder.has_another)
        cur_state.on_digit = ScanState()
        builder.apply( cur_state.on_digit )
      elseIf (builder.end_state)
        cur_state.on_digit = builder.end_state
        # No end_state means we've reached the end of an indefinite repeat branch (e.g. digit*);
        # we'll leave this dead end for now and come back and fix it in the next pass.
      endIf

    method apply( builder:PatternGraphBuilder, cur_state:ScanState, ch:Character )
      local new_state : ScanState
      if (cur_state.links.contains(ch))
        new_state = cur_state.link( ch )
        builder.cloned.apply( new_state )
      endIf

    method to->String
      return "digit"
endClass

class StringPattern( t, value:String ) : Pattern
endClass

class CharacterPattern( t, ch:Character ) : Pattern
  GLOBAL PROPERTIES
    instance : CharacterPattern

  METHODS
    method apply( builder:PatternGraphBuilder, cur_state:ScanState )
      local new_state : ScanState
      if (cur_state.links.contains(ch))
        new_state = cur_state.link( ch )
      elseIf (cur_state.on_letter and ((ch>='a' and ch<='z') or (ch>='A' and ch<='Z')))
        new_state = cur_state.on_letter.cloned
        cur_state.links[ ch ] = new_state
      elseIf (cur_state.on_digit and ch>='0' and ch<='9')
        new_state = cur_state.on_digit.cloned
        cur_state.links[ ch ] = new_state
      elseIf (builder.has_another)
        new_state = cur_state.link( ch )
      elseIf (builder.end_state)
        new_state = builder.end_state
        cur_state.links[ ch ] = new_state
        # No end_state means we've reached the end of an indefinite repeat branch (e.g. a*);
        # we'll leave this dead end for now and come back and fix it in the next pass.
      endIf
      builder.apply( new_state )

    #{
    method apply( cur_state:ScanState, final_state:ScanState )->ScanState
      if (cur_state.links.contains(value))
        cur_state = cur_state.link( value )
        if (final_state)
          if (cur_state.statements.is_empty) cur_state.statements.add( final_state.statements )
        endIf
        return cur_state
      elseIf (final_state)
        cur_state.links[ value ] = final_state
        return final_state
      else
        return cur_state.link( value )
      endIf
      }#

    method to->String
      return "'$'" (ch.to_escaped_ascii)
endClass

