module Froley
  uses ParseKit<<Froley>>

augment Cmd
  METHODS
    method is_ch->Logical
      return false

    method is_count->Logical
      return false

    method is_integer->Logical
      return false

    method jump_if_true->Opcode
      throw UnsupportedOperationError()

    method jump_if_false->Opcode
      which (jump_if_true)
        case Opcode.JUMP_EQ: return Opcode.JUMP_NE
        case Opcode.JUMP_NE: return Opcode.JUMP_EQ
        case Opcode.JUMP_LT: return Opcode.JUMP_GE
        case Opcode.JUMP_LE: return Opcode.JUMP_GT
        case Opcode.JUMP_GT: return Opcode.JUMP_LE
        case Opcode.JUMP_GE: return Opcode.JUMP_LT
        others
          throw UnsupportedOperationError()
      endWhich

    method resolved->Cmd
      return this

    method resolve_assignment( new_value:Cmd )->Cmd
      throw t.error( "Illegal assignment." )

    method to->Int32
      throw UnsupportedOperationError()

    method write( assembler:Assembler )
      throw UnsupportedOperationError()

    method write_add( assembler:Assembler, expression:Cmd )
      throw t.error( "Illegal operation target - target must be 'ch' or 'count'." )

    method write_subtract( assembler:Assembler, expression:Cmd )
      throw t.error( "Illegal operation target - target must be 'ch' or 'count'." )

    method error( message:String )->Error
      return t.error( message )
endAugment

augment CmdStatements
  METHODS
    method resolve
      forEach (statement at index in this)
        this[ index ] = statement.resolved
      endForEach

    method write( assembler:Assembler )
      (forEach in this).write( assembler )
endAugment


augment CmdArgs
  METHODS
    method resolve
      forEach (statement at index in this)
        this[ index ] = statement.resolved
      endForEach

    method write( assembler:Assembler )
      (forEach in this).write( assembler )
endAugment

class CmdGoTo( t, label_name:String ) : Cmd
  METHODS
    method write( assembler:Assembler )
      assembler.[ write(Opcode.JUMP), write_address(label_name) ]

    method to->String
      return "goto"
endClass

class CmdHalt : Cmd
  METHODS
    method write( assembler:Assembler )
      assembler.write( Opcode.HALT )

    method to->String
      return "halt"
endClass

class CmdLabel( t, name:String ) : Cmd
  METHODS
    method write( assembler:Assembler )
      if (assembler.label(name).exists)
        throw error( "Label <$> has already been defined." (name) )
      endIf
      assembler.define( name )

    method to->String
      return "<$>" (name)
endClass

class CmdPrintCh( t ) : Cmd
  METHODS
    method write( assembler:Assembler )
      assembler.write( Opcode.PRINT_CH )

    method to->String
      return "print ch"
endClass

class CmdPrintCount( t ) : Cmd
  METHODS
    method write( assembler:Assembler )
      assembler.write( Opcode.PRINT_COUNT )

    method to->String
      return "print count"
endClass

class CmdPrintCharacter( t, code:Int32 ) : Cmd
  METHODS
    method write( assembler:Assembler )
      assembler.write( Opcode.PRINT_CHARACTER, code )

    method to->String
      return "print '$'" (code->Character.to_escaped_ascii)
endClass


class CmdPrintString( t, value:String ) : Cmd
  METHODS
    method write( assembler:Assembler )
      assembler.write( Opcode.PRINT_STRING, value )

    method to->String
      return ''print "$"'' (value.to_escaped_ascii)
endClass

class CmdAccess( t, name:String ) : Cmd
  METHODS
    method init( t )
      name = t.text

    method to->String
      return name

    method resolve_assignment( new_value:Cmd )->Cmd
      throw t.error( "Illegal assignment target. Valid targets are 'ch' and 'count'." )

    method write( assembler:Assembler )
      throw t.error( ''No such function or register "$".'' (name) )
endClass

class CmdAssign : CmdBinary
  METHODS
    method resolved->Cmd
      return left.resolve_assignment( right )

    method write( assembler:Assembler )
      throw t.error( "Illegal assignment: $ = $" (left,right) )
endClass

class CmdLiteralInt32( t, value:Int32 ) : Cmd
  METHODS
    method init( t )
      value = t->Int32

    method is_integer->Logical
      return true

    method to->Int32
      return value

    method to->String
      return value->String
endClass

class CmdAdd( t, target:Cmd, value:Cmd ) : Cmd
  METHODS
    method write( assembler:Assembler )
      target.write_add( assembler, value )
endClass

class CmdSubtract( t, target:Cmd, value:Cmd ) : Cmd
  METHODS
    method write( assembler:Assembler )
      target.write_subtract( assembler, value )
endClass

class CmdCall( t, label_name:String ) : Cmd
  METHODS
    method write( assembler:Assembler )
      assembler.write( Opcode.CALL )
      assembler.write_address( label_name )
endClass

class CmdReturn( t ) : Cmd
  METHODS
    method write( assembler:Assembler )
      assembler.write( Opcode.RETURN )
endClass

class CmdRead( t ) : Cmd
  METHODS
    method write( assembler:Assembler )
      assembler.write( Opcode.READ_AND_DISCARD )
endClass

class CmdScanDigits( t, min_digits:Int32, max_digits:Int32, base:Int32 ) : Cmd
  PROPERTIES
    is_resolved : Logical

  METHODS
    method jump_if_true->Opcode
      return Opcode.JUMP_GE

    method to->String
      return "scanDigits $..$ base $" (min_digits,max_digits,base)

    method write( assembler:Assembler )
      if (is_resolved)
        assembler.write( Opcode.SCAN_DIGITS )
        assembler.write( min_digits )
        assembler.write( max_digits )
        assembler.write( base )
      else
        throw t.error( "Syntax error. Expected 'ch = scanDigits <min-digits>[..<max-digits>] [base <number-base>]'." )
      endIf
endClass


class CmdWhile( t, condition:Cmd ) : Cmd
  PROPERTIES
    statements = CmdStatements()

  METHODS
    method resolved->Cmd
      condition = condition.resolved
      statements.resolve
      return this

    method write( assembler:Assembler )
      local label_test = Label()
      local label_top  = Label()
      assembler.write( Opcode.JUMP, label_test )
      assembler.define( label_top )
      statements.write( assembler )
      assembler.define( label_test )
      condition.write( assembler )
      assembler.write( condition.jump_if_true, label_top )
endClass

class CmdIf( t, condition:Cmd ) : Cmd
  PROPERTIES
    statements      = CmdStatements()
    else_statements : CmdStatements

  METHODS
    method resolved->Cmd
      condition = condition.resolved
      statements.resolve
      if (else_statements) else_statements.resolve
      return this

    method write( assembler:Assembler )
      local label_else   = Label()
      local label_end_if = Label()
      condition.write( assembler )
      assembler.write( condition.jump_if_false, label_else )
      statements.write( assembler )
      assembler.write( Opcode.JUMP, label_end_if )
      assembler.define( label_else )
      if (else_statements) else_statements.write( assembler )
      assembler.define( label_end_if )
endClass

class CmdHasAnother( t ) : Cmd
  METHODS
    method jump_if_true->Opcode
      return Opcode.JUMP_GT

    method to->String
      return "hasAnother"

    method write( assembler:Assembler )
      assembler.write( Opcode.HAS_ANOTHER )
endClass

class CmdSetChToInt32( t, value:Int32 ) : Cmd
  METHODS
    method write( assembler:Assembler )
      assembler.write( Opcode.SET_CH_INT32, value )
endClass

class CmdSetChToCount( t ) : Cmd
  METHODS
    method write( assembler:Assembler )
      assembler.write( Opcode.SET_CH_TO_COUNT )
endClass

class CmdReadCh( t ) : Cmd
  METHODS
    method write( assembler:Assembler )
      assembler.write( Opcode.READ_CH )
endClass

class CmdRegisterCh( t ) : Cmd
  METHODS
    method is_ch->Logical
      return true

    method resolve_assignment( new_value:Cmd )->Cmd
      local cmd_int32 = new_value as CmdLiteralInt32
      if (new_value.is_integer)
        return CmdSetChToInt32( t, new_value->Int32 )
      elseIf (new_value instanceOf CmdRegisterCount)
        return CmdSetChToCount( t )
      elseIf (new_value instanceOf CmdRead)
        return CmdReadCh( t )
      elseIf (new_value instanceOf CmdScanDigits)
        (new_value as CmdScanDigits).is_resolved = true
        return new_value
      else
        throw t.error( "Illegal 'ch' assignment. Expected 'count', 'read', 'scanDigits', or an integer." )
      endIf

    method to->String
      return "ch"

    method write( assembler:Assembler )
      assembler.write( Opcode.TEST_CH )

    method write_add( assembler:Assembler, expression:Cmd )
      local cmd_int = expression as CmdLiteralInt32
      if (cmd_int)
        assembler.write( Opcode.ADD_CH_INT32, cmd_int.value )
      else
        throw expression.error( "Illegal operation value; integer expected." )
      endIf

    method write_subtract( assembler:Assembler, expression:Cmd )
      local cmd_int = expression as CmdLiteralInt32
      if (cmd_int)
        assembler.write( Opcode.SUB_CH_INT32, cmd_int.value )
      else
        throw expression.error( "Illegal operation value; integer expected." )
      endIf
endClass

class CmdSetCountToInt32( t, value:Int32 ) : Cmd
  METHODS
    method write( assembler:Assembler )
      assembler.write( Opcode.SET_COUNT_TO_INT32, value )
endClass

class CmdSetCountToCh( t ) : Cmd
  METHODS
    method write( assembler:Assembler )
      assembler.write( Opcode.SET_COUNT_TO_CH )
endClass


class CmdRegisterCount( t ) : Cmd
  METHODS
    method is_count->Logical
      return true

    method jump_if_true->Opcode
      return Opcode.JUMP_GT

    method resolve_assignment( new_value:Cmd )->Cmd
      if (new_value.is_integer)
        return CmdSetCountToInt32( t, new_value->Int32 )
      elseIf (new_value.is_ch)
        return CmdSetCountToCh( t )
      else
        throw t.error( "Illegal assignment value. 'count' can be assigned ether 'ch' or an integer." )
      endIf

    method to->String
      return "count"

    method write( assembler:Assembler )
      assembler.write( Opcode.TEST_COUNT )

    method write_add( assembler:Assembler, expression:Cmd )
      local cmd_int32 = expression as CmdLiteralInt32
      if (cmd_int32)
        assembler.write( Opcode.ADD_C_INT32, cmd_int32.value )
      else
        throw expression.error( "Illegal operation value; integer expected." )
      endIf

    method write_subtract( assembler:Assembler, expression:Cmd )
      local cmd_int32 = expression as CmdLiteralInt32
      if (cmd_int32)
        assembler.write( Opcode.SUB_C_INT32, cmd_int32.value )
      else
        throw expression.error( "Illegal operation value; integer expected." )
      endIf
endClass

class CmdPush( t ) : Cmd
  METHODS
    method write( assembler:Assembler )
      assembler.write( Opcode.PUSH_CH )
endClass

class CmdPop( t ) : Cmd
  METHODS
    method write( assembler:Assembler )
      assembler.write( Opcode.POP_CH )
endClass

class CmdCompare : CmdBinary
  METHODS
    method write( assembler:Assembler )
      if (left.is_ch)
        if (right.is_integer)
          assembler.write( Opcode.COMPARE_CH_INT32, right->Int32 )
          return
        endIf
      endIf
      if (left.is_count)
        if (right.is_integer)
          assembler.write( Opcode.COMPARE_COUNT_INT32, right->Int32 )
          return
        endIf
      endIf
      throw t.error( "Unsupported comparison between '$' and '$'." (left,right) )
endClass

class CmdCompareEQ : CmdCompare
  METHODS
    method jump_if_true->Opcode
      return Opcode.JUMP_EQ
endClass

class CmdCompareNE : CmdCompare
  METHODS
    method jump_if_true->Opcode
      return Opcode.JUMP_NE
endClass

class CmdCompareLT : CmdCompare
  METHODS
    method jump_if_true->Opcode
      return Opcode.JUMP_LT
endClass

class CmdCompareLE : CmdCompare
  METHODS
    method jump_if_true->Opcode
      return Opcode.JUMP_LE
endClass

class CmdCompareGT : CmdCompare
  METHODS
    method jump_if_true->Opcode
      return Opcode.JUMP_GT
endClass

class CmdCompareGE : CmdCompare
  METHODS
    method jump_if_true->Opcode
      return Opcode.JUMP_GE
endClass

