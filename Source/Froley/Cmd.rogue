module Froley
  uses ParseKit<<Froley>>

augment Cmd
  METHODS
    method is_ch->Logical
      return false

    method is_count->Logical
      return false

    method is_integer->Logical
      return false

    method jump_if_true->Opcode
      throw UnsupportedOperationError()

    method jump_if_false->Opcode
      which (jump_if_true)
        case Opcode.JUMP_EQ: return Opcode.JUMP_NE
        case Opcode.JUMP_NE: return Opcode.JUMP_EQ
        case Opcode.JUMP_LT: return Opcode.JUMP_GE
        case Opcode.JUMP_LE: return Opcode.JUMP_GT
        case Opcode.JUMP_GT: return Opcode.JUMP_LE
        case Opcode.JUMP_GE: return Opcode.JUMP_LT
        others
          throw UnsupportedOperationError()
      endWhich

    method to->Int32
      throw UnsupportedOperationError()

    method write( assembler:Assembler )
      throw UnsupportedOperationError()

    method write_assignment( assembler:Assembler, new_value:Cmd )
      throw t.error( "Illegal assignment." )

    method write_add( assembler:Assembler, expression:Cmd )
      throw t.error( "Illegal operation target - target must be 'ch' or 'count'." )

    method write_subtract( assembler:Assembler, expression:Cmd )
      throw t.error( "Illegal operation target - target must be 'ch' or 'count'." )

    method error( message:String )->Error
      return t.error( message )
endAugment

augment CmdStatements
  METHODS
    method write( assembler:Assembler )
      (forEach in this).write( assembler )
endAugment


augment CmdArgs
  METHODS
    method write( assembler:Assembler )
      (forEach in this).write( assembler )
endAugment

class CmdGoTo( t, label_name:String ) : Cmd
  METHODS
    method write( assembler:Assembler )
      assembler.[ write(Opcode.JUMP), write_address(label_name) ]

    method to->String
      return "goto"
endClass

class CmdHalt : Cmd
  METHODS
    method write( assembler:Assembler )
      assembler.write( Opcode.HALT )

    method to->String
      return "halt"
endClass

class CmdLabel( t, name:String ) : Cmd
  METHODS
    method write( assembler:Assembler )
      if (assembler.label(name).exists)
        throw error( "Label <$> has already been defined." (name) )
      endIf
      assembler.define( name )

    method to->String
      return "<$>" (name)
endClass

class CmdPrintCh( t ) : Cmd
  METHODS
    method write( assembler:Assembler )
      assembler.write( Opcode.PRINT_CH )

    method to->String
      return "print ch"
endClass

class CmdPrintCount( t ) : Cmd
  METHODS
    method write( assembler:Assembler )
      assembler.write( Opcode.PRINT_COUNT )

    method to->String
      return "print count"
endClass

class CmdPrintCharacter( t, code:Int32 ) : Cmd
  METHODS
    method write( assembler:Assembler )
      assembler.write( Opcode.PRINT_CHARACTER, code )

    method to->String
      return "print '$'" (code->Character.to_escaped_ascii)
endClass


class CmdPrintString( t, value:String ) : Cmd
  METHODS
    method write( assembler:Assembler )
      assembler.write( Opcode.PRINT_STRING, value )

    method to->String
      return ''print "$"'' (value.to_escaped_ascii)
endClass

class CmdAccess( t, name:String ) : Cmd
  METHODS
    method init( t )
      name = t.text

    method write( assembler:Assembler )
      throw t.error( ''No such function or register "$".'' (name) )

    method write_assignment( assembler:Assembler, new_value:Cmd )
      throw t.error( "Illegal assignment target. Valid targets are 'ch' and 'count'." )

    method to->String
      return name
endClass

class CmdAssign( t, target:Cmd, new_value:Cmd ) : Cmd
  METHODS
    method write( assembler:Assembler )
      target.write_assignment( assembler, new_value )
endClass

class CmdLiteralInt32( t, value:Int32 ) : Cmd
  METHODS
    method init( t )
      value = t->Int32

    method is_integer->Logical
      return true

    method to->Int32
      return value

    method to->String
      return value->String
endClass

class CmdAdd( t, target:Cmd, value:Cmd ) : Cmd
  METHODS
    method write( assembler:Assembler )
      target.write_add( assembler, value )
endClass

class CmdSubtract( t, target:Cmd, value:Cmd ) : Cmd
  METHODS
    method write( assembler:Assembler )
      target.write_subtract( assembler, value )
endClass

class CmdCall( t, label_name:String ) : Cmd
  METHODS
    method write( assembler:Assembler )
      assembler.write( Opcode.CALL )
      assembler.write_address( label_name )
endClass

class CmdReturn( t ) : Cmd
  METHODS
    method write( assembler:Assembler )
      assembler.write( Opcode.RETURN )
endClass

class CmdRead( t ) : Cmd
  METHODS
    method write( assembler:Assembler )
      assembler.write( Opcode.READ )
endClass

class CmdWhile( t, condition:Cmd ) : Cmd
  PROPERTIES
    statements = CmdStatements()

  METHODS
    method write( assembler:Assembler )
      local label_test = Label()
      local label_top  = Label()
      assembler.write( Opcode.JUMP, label_test )
      assembler.define( label_top )
      statements.write( assembler )
      assembler.define( label_test )
      condition.write( assembler )
      assembler.write( condition.jump_if_true, label_top )
endClass

class CmdIf( t, condition:Cmd ) : Cmd
  PROPERTIES
    statements      = CmdStatements()
    else_statements : CmdStatements

  METHODS
    method write( assembler:Assembler )
      local label_else   = Label()
      local label_end_if = Label()
      condition.write( assembler )
throw t.error( "TODO" )
#{
      assembler.write( Opcode.JUMP_IF_FALSE, label_else )
      statements.write( assembler )
      assembler.write( Opcode.JUMP, label_end_if )
      assembler.define( label_else )
      if (else_statements) else_statements.write( assembler )
      assembler.define( label_end_if )
}#
endClass

class CmdHasAnother( t ) : Cmd
  METHODS
    method jump_if_true->Opcode
      return Opcode.JUMP_GT

    method to->String
      return "hasAnother"

    method write( assembler:Assembler )
      assembler.write( Opcode.HAS_ANOTHER )
endClass

class CmdRegisterCh( t ) : Cmd
  METHODS
    method is_ch->Logical
      return true

    method to->String
      return "ch"

    method write( assembler:Assembler )
      assembler.write( Opcode.TEST_CH )

    method write_assignment( assembler:Assembler, new_value:Cmd )
      local cmd_int32 = new_value as CmdLiteralInt32
      if (cmd_int32)
        assembler.write( Opcode.SET_CH_INT32, cmd_int32.value )
      elseIf (new_value instanceOf CmdRegisterCount)
        assembler.write( Opcode.MOVE_C_TO_CH )
      else
        throw t.error( "Illegal assignment value. 'ch' can be assigned either 'count' or an integer." )
      endIf

    method write_add( assembler:Assembler, expression:Cmd )
      local cmd_int = expression as CmdLiteralInt32
      if (cmd_int)
        assembler.write( Opcode.ADD_CH_INT32, cmd_int.value )
      else
        throw expression.error( "Illegal operation value; integer expected." )
      endIf

    method write_subtract( assembler:Assembler, expression:Cmd )
      local cmd_int = expression as CmdLiteralInt32
      if (cmd_int)
        assembler.write( Opcode.SUB_CH_INT32, cmd_int.value )
      else
        throw expression.error( "Illegal operation value; integer expected." )
      endIf
endClass

class CmdRegisterCount( t ) : Cmd
  METHODS
    method is_count->Logical
      return true

    method jump_if_true->Opcode
      return Opcode.JUMP_GT

    method to->String
      return "count"

    method write( assembler:Assembler )
      assembler.write( Opcode.TEST_COUNT )

    method write_assignment( assembler:Assembler, new_value:Cmd )
      local cmd_int32 = new_value as CmdLiteralInt32
      if (cmd_int32)
        assembler.write( Opcode.SET_C, cmd_int32.value )
      elseIf (new_value instanceOf CmdRegisterCh)
        assembler.write( Opcode.MOVE_CH_TO_C )
      else
        throw t.error( "Illegal assignment value. 'count' can be assigned ether 'ch' or an integer." )
      endIf

    method write_add( assembler:Assembler, expression:Cmd )
      local cmd_int32 = expression as CmdLiteralInt32
      if (cmd_int32)
        assembler.write( Opcode.ADD_C_INT32, cmd_int32.value )
      else
        throw expression.error( "Illegal operation value; integer expected." )
      endIf

    method write_subtract( assembler:Assembler, expression:Cmd )
      local cmd_int32 = expression as CmdLiteralInt32
      if (cmd_int32)
        assembler.write( Opcode.SUB_C_INT32, cmd_int32.value )
      else
        throw expression.error( "Illegal operation value; integer expected." )
      endIf
endClass

class CmdPush( t ) : Cmd
  METHODS
    method write( assembler:Assembler )
      assembler.write( Opcode.PUSH_CH )
endClass

class CmdPop( t ) : Cmd
  METHODS
    method write( assembler:Assembler )
      assembler.write( Opcode.POP_CH )
endClass

class CmdCompare : CmdBinary
  METHODS
    method write( assembler:Assembler )
      if (left.is_ch)
        if (right.is_integer)
          assembler.write( Opcode.COMPARE_CH_INT32, right->Int32 )
          return
        endIf
      endIf
      if (left.is_count)
        if (right.is_integer)
          assembler.write( Opcode.COMPARE_COUNT_INT32, right->Int32 )
          return
        endIf
      endIf
      throw t.error( "Unsupported comparison between '$' and '$'." (left,right) )
endClass

class CmdCompareEQ : CmdCompare
  METHODS
    method jump_if_true->Opcode
      return Opcode.JUMP_EQ
endClass

class CmdCompareNE : CmdCompare
  METHODS
    method jump_if_true->Opcode
      return Opcode.JUMP_NE
endClass

class CmdCompareLT : CmdCompare
  METHODS
    method jump_if_true->Opcode
      return Opcode.JUMP_LT
endClass

class CmdCompareLE : CmdCompare
  METHODS
    method jump_if_true->Opcode
      return Opcode.JUMP_LE
endClass

class CmdCompareGT : CmdCompare
  METHODS
    method jump_if_true->Opcode
      return Opcode.JUMP_GT
endClass

class CmdCompareGE : CmdCompare
  METHODS
    method jump_if_true->Opcode
      return Opcode.JUMP_GE
endClass

class CmdReadNumber( t, base:Int32 ) : Cmd
  METHODS
    method write( assembler:Assembler )
      assembler.write( Opcode.READ_NUMBER, base )
endClass

