module Froley
  uses ParseKit<<Froley>>

augment Cmd
  METHODS
    method is_ch->Logical
      return false

    method is_count->Logical
      return false

    method is_integer->Logical
      return false

    method jump_if_true->Opcode
      throw t.error( "Value expected." )

    method jump_if_false->Opcode
      which (jump_if_true)
        case Opcode.JUMP_EQ: return Opcode.JUMP_NE
        case Opcode.JUMP_NE: return Opcode.JUMP_EQ
        case Opcode.JUMP_LT: return Opcode.JUMP_GE
        case Opcode.JUMP_LE: return Opcode.JUMP_GT
        case Opcode.JUMP_GT: return Opcode.JUMP_LE
        case Opcode.JUMP_GE: return Opcode.JUMP_LT
        others
          throw UnsupportedOperationError()
      endWhich

    method resolved->Cmd
      return this

    method resolve_assignment( new_value:Cmd )->Cmd
      throw t.error( "Illegal assignment." )

    method to->Int32
      throw UnsupportedOperationError()

    method write( assembler:Assembler )
      throw UnsupportedOperationError()

    method write_add( assembler:Assembler, expression:Cmd )
      throw t.error( "Illegal operation target - target must be 'ch' or 'count'." )

    method write_subtract( assembler:Assembler, expression:Cmd )
      throw t.error( "Illegal operation target - target must be 'ch' or 'count'." )

    method error( message:String )->Error
      return t.error( message )
endAugment

augment CmdStatements
  METHODS
    method resolve
      forEach (statement at index in this)
        this[ index ] = statement.resolved
      endForEach

    method write( assembler:Assembler )
      (forEach in this).write( assembler )
endAugment


augment CmdArgs
  METHODS
    method resolve
      forEach (statement at index in this)
        this[ index ] = statement.resolved
      endForEach

    method write( assembler:Assembler )
      (forEach in this).write( assembler )
endAugment

class CmdStatement( t, name:String, opcode:Opcode ) : Cmd
  # Generic statement with opcode and no operands
  METHODS
    method to->String
      return name

    method write( assembler:Assembler )
      assembler.write( opcode )
endClass

class CmdGoTo( t, label_name:String ) : Cmd
  METHODS
    method write( assembler:Assembler )
      assembler.[ write(Opcode.JUMP), write_address(label_name) ]

    method to->String
      return "goto"
endClass

class CmdJump( t, address:Int32 ) : Cmd
  METHODS
    method write( assembler:Assembler )
      assembler.write( Opcode.JUMP, address )

    method to->String
      return "jump " + address
endClass

class CmdLabel( t, name:String ) : Cmd
  METHODS
    method write( assembler:Assembler )
      if (assembler.label(name).exists)
        throw error( "Label <$> has already been defined." (name) )
      endIf
      assembler.define( name )

    method to->String
      return "<$>" (name)
endClass

class CmdPrintCharacter( t, code:Int32 ) : Cmd
  METHODS
    method write( assembler:Assembler )
      assembler.write( Opcode.PRINT_CHARACTER, code )

    method to->String
      return "print '$'" (code->Character.to_escaped_ascii)
endClass


class CmdPrintString( t, value:String ) : Cmd
  METHODS
    method write( assembler:Assembler )
      assembler.write( Opcode.PRINT_STRING, value )

    method to->String
      return ''print "$"'' (value.to_escaped_ascii)
endClass

class CmdAccess( t, name:String ) : Cmd
  METHODS
    method init( t )
      name = t.text

    method to->String
      return name

    method resolve_assignment( new_value:Cmd )->Cmd
      throw t.error( "Illegal assignment target. Valid targets are 'ch' and 'count'." )

    method write( assembler:Assembler )
      throw t.error( ''No such function or register "$".'' (name) )
endClass

class CmdAssign : CmdBinary
  METHODS
    method resolved->Cmd
      return left.resolve_assignment( right )

    method write( assembler:Assembler )
      throw t.error( "Illegal assignment: $ = $" (left,right) )
endClass

class CmdLiteralInt32( t, value:Int32 ) : Cmd
  METHODS
    method init( t )
      value = t->Int32

    method is_integer->Logical
      return true

    method to->Int32
      return value

    method to->String
      return value->String
endClass

class CmdAdd( t, target:Cmd, value:Cmd ) : Cmd
  METHODS
    method write( assembler:Assembler )
      target.write_add( assembler, value )
endClass

class CmdSubtract( t, target:Cmd, value:Cmd ) : Cmd
  METHODS
    method write( assembler:Assembler )
      target.write_subtract( assembler, value )
endClass

class CmdCall( t, label_name:String ) : Cmd
  METHODS
    method write( assembler:Assembler )
      assembler.write( Opcode.CALL )
      assembler.write_address( label_name )
endClass

class CmdRead( t ) : Cmd
  METHODS
    method write( assembler:Assembler )
      assembler.write( Opcode.READ_AND_DISCARD )
endClass

class CmdScanDigits( t, min_digits:Int32, max_digits:Int32, base:Int32 ) : Cmd
  PROPERTIES
    is_resolved : Logical

  METHODS
    method jump_if_true->Opcode
      return Opcode.JUMP_GE

    method to->String
      return "scanDigits $..$ base $" (min_digits,max_digits,base)

    method write( assembler:Assembler )
      if (is_resolved)
        assembler.write( Opcode.SCAN_DIGITS )
        assembler.write( min_digits )
        assembler.write( max_digits )
        assembler.write( base )
      else
        throw t.error( "Syntax error. Expected 'ch = scanDigits <min-digits>[..<max-digits>] [base <number-base>]'." )
      endIf
endClass


class CmdWhile( t, condition:Cmd ) : Cmd
  PROPERTIES
    statements = CmdStatements()

  METHODS
    method resolved->Cmd
      condition = condition.resolved
      statements.resolve
      return this

    method write( assembler:Assembler )
      local label_test = Label()
      local label_top  = Label()
      assembler.write( Opcode.JUMP, label_test )
      assembler.define( label_top )
      statements.write( assembler )
      assembler.define( label_test )
      condition.write( assembler )
      assembler.write( condition.jump_if_true, label_top )
endClass

class CmdIf( t, condition:Cmd ) : Cmd
  PROPERTIES
    statements      = CmdStatements()
    else_statements : CmdStatements

  METHODS
    method resolved->Cmd
      condition = condition.resolved
      statements.resolve
      if (else_statements) else_statements.resolve
      return this

    method write( assembler:Assembler )
      local label_else   = Label()
      local label_end_if = Label()
      condition.write( assembler )
      assembler.write( condition.jump_if_false, label_else )
      statements.write( assembler )
      assembler.write( Opcode.JUMP, label_end_if )
      assembler.define( label_else )
      if (else_statements) else_statements.write( assembler )
      assembler.define( label_end_if )
endClass

class CmdHasAnother( t ) : Cmd
  METHODS
    method jump_if_true->Opcode
      return Opcode.JUMP_GT

    method to->String
      return "hasAnother"

    method write( assembler:Assembler )
      assembler.write( Opcode.HAS_ANOTHER )
endClass

class CmdSetChToInt32( t, value:Int32 ) : Cmd
  METHODS
    method jump_if_true->Opcode
      return Opcode.JUMP_NE

    method write( assembler:Assembler )
      assembler.write( Opcode.SET_CH_INT32, value )
endClass

class CmdSetChToCount( t ) : Cmd
  METHODS
    method jump_if_true->Opcode
      return Opcode.JUMP_NE

    method write( assembler:Assembler )
      assembler.write( Opcode.SET_CH_TO_COUNT )
endClass

class CmdReadCh( t ) : Cmd
  METHODS
    method jump_if_true->Opcode
      return Opcode.JUMP_NE

    method write( assembler:Assembler )
      assembler.write( Opcode.READ_CH )
endClass

class CmdRegisterCh( t ) : Cmd
  METHODS
    method is_ch->Logical
      return true

    method resolve_assignment( new_value:Cmd )->Cmd
      local cmd_int32 = new_value as CmdLiteralInt32
      if (new_value.is_integer)
        return CmdSetChToInt32( t, new_value->Int32 )
      elseIf (new_value instanceOf CmdRegisterCount)
        return CmdSetChToCount( t )
      elseIf (new_value instanceOf CmdRead)
        return CmdReadCh( t )
      elseIf (new_value instanceOf CmdPeek)
        return CmdPeekChInt32( t, 0 )
      elseIf (new_value instanceOf CmdPeekInt32)
        return CmdPeekChInt32( t, (new_value as CmdPeekInt32).lookahead )
      elseIf (new_value instanceOf CmdPeekCount)
        return CmdPeekChCount( t )
      elseIf (new_value instanceOf CmdScanDigits)
        (new_value as CmdScanDigits).is_resolved = true
        return new_value
      elseIf (new_value instanceOf CmdPop)
        return CmdStatement( t, "ch = pop", Opcode.POP_CH )
      else
        throw t.error( "Illegal 'ch' assignment. Expected 'count', 'read', 'scanDigits', or an integer." )
      endIf

    method to->String
      return "ch"

    method write( assembler:Assembler )
      assembler.write( Opcode.TEST_CH )

    method write_add( assembler:Assembler, expression:Cmd )
      local cmd_int = expression as CmdLiteralInt32
      if (cmd_int)
        assembler.write( Opcode.ADD_CH_INT32, cmd_int.value )
      else
        throw expression.error( "Illegal operation value; integer expected." )
      endIf

    method write_subtract( assembler:Assembler, expression:Cmd )
      local cmd_int = expression as CmdLiteralInt32
      if (cmd_int)
        assembler.write( Opcode.SUB_CH_INT32, cmd_int.value )
      else
        throw expression.error( "Illegal operation value; integer expected." )
      endIf
endClass

class CmdSetCountToInt32( t, value:Int32 ) : Cmd
  METHODS
    method jump_if_true->Opcode
      return Opcode.JUMP_NE

    method write( assembler:Assembler )
      assembler.write( Opcode.SET_COUNT_TO_INT32, value )
endClass

class CmdSetCountToCh( t ) : Cmd
  METHODS
    method jump_if_true->Opcode
      return Opcode.JUMP_NE

    method write( assembler:Assembler )
      assembler.write( Opcode.SET_COUNT_TO_CH )
endClass


class CmdRegisterCount( t ) : Cmd
  METHODS
    method is_count->Logical
      return true

    method jump_if_true->Opcode
      return Opcode.JUMP_GT

    method resolve_assignment( new_value:Cmd )->Cmd
      if (new_value.is_integer)
        return CmdSetCountToInt32( t, new_value->Int32 )
      elseIf (new_value.is_ch)
        return CmdSetCountToCh( t )
      else
        throw t.error( "Illegal assignment value. 'count' can be assigned ether 'ch' or an integer." )
      endIf

    method to->String
      return "count"

    method write( assembler:Assembler )
      assembler.write( Opcode.TEST_COUNT )

    method write_add( assembler:Assembler, expression:Cmd )
      local cmd_int32 = expression as CmdLiteralInt32
      if (cmd_int32)
        assembler.write( Opcode.ADD_C_INT32, cmd_int32.value )
      else
        throw expression.error( "Illegal operation value; integer expected." )
      endIf

    method write_subtract( assembler:Assembler, expression:Cmd )
      local cmd_int32 = expression as CmdLiteralInt32
      if (cmd_int32)
        assembler.write( Opcode.SUB_C_INT32, cmd_int32.value )
      else
        throw expression.error( "Illegal operation value; integer expected." )
      endIf
endClass

class CmdPop( t ) : Cmd
  METHODS
    method write( assembler:Assembler )
      throw t.error( "Syntax error - expected 'ch = pop'." )
endClass

class CmdCompare<<$OPCODE>> : CmdBinary
  METHODS
    method jump_if_true->Opcode
      return Opcode.$OPCODE

    method to->String
      local symbol = "<>"
      which (Opcode.$OPCODE)
        case Opcode.JUMP_EQ: symbol = "=="
        case Opcode.JUMP_NE: symbol = "!="
        case Opcode.JUMP_LT: symbol = "<"
        case Opcode.JUMP_LE: symbol = "<="
        case Opcode.JUMP_GT: symbol = ">"
        case Opcode.JUMP_GE: symbol = ">="
      endWhich
      return "$ $ $" (left,symbol,right)

    method write( assembler:Assembler )
      if (left.is_ch)
        if (right.is_integer)
          assembler.write( Opcode.COMPARE_CH_INT32, right->Int32 )
          return
        endIf
      endIf
      if (left.is_count)
        if (right.is_integer)
          assembler.write( Opcode.COMPARE_COUNT_INT32, right->Int32 )
          return
        endIf
      endIf
      throw t.error( "Unsupported comparison between '$' and '$'." (left,right) )
endClass

class CmdCompareEQ : CmdCompare<<JUMP_EQ>>;
class CmdCompareNE : CmdCompare<<JUMP_NE>>;
class CmdCompareLT : CmdCompare<<JUMP_LT>>;
class CmdCompareLE : CmdCompare<<JUMP_LE>>;
class CmdCompareGT : CmdCompare<<JUMP_GT>>;
class CmdCompareGE : CmdCompare<<JUMP_GE>>;

class CmdCollectCharacter( t, value:Int32 ) : Cmd
  METHODS
    method to->String
      return "collect '$'" (value->Character.to_escaped_ascii)

    method write( assembler:Assembler )
      assembler.write( Opcode.COLLECT_CHARACTER, value )
endClass

class CmdCollectString( t, value:String ) : Cmd
  METHODS
    method to->String
      return ''collect "$"'' (value.to_escaped_ascii)

    method write( assembler:Assembler )
      assembler.write( Opcode.COLLECT_STRING, value )
endClass

class CmdAcceptInt32( t, token_type:Int32 ) : Cmd
  METHODS
    method to->String
      return Froley.token_name( token_type )

    method write( assembler:Assembler )
      assembler.write( Opcode.ACCEPT_INT32, token_type )
endClass

class CmdPeek( t ) : Cmd
  METHODS
    method to->String
      return "peek"

    method write( assembler:Assembler )
      throw t.error( "Syntax error - expected 'ch = peek'." )
endClass

class CmdPeekCount( t ) : Cmd
  METHODS
    method to->String
      return "peek(count)"

    method write( assembler:Assembler )
      throw t.error( "Syntax error - expected 'ch = peek(count)'." )
endClass

class CmdPeekInt32( t, lookahead:Int32 ) : Cmd
  METHODS
    method to->String
      return "peek($)" (lookahead)

    method write( assembler:Assembler )
      throw t.error( "Syntax error - expected 'ch = peek($)'." (lookahead) )
endClass

class CmdPeekChCount( t ) : Cmd
  METHODS
    method to->String
      return "ch = peek(count)"

    method write( assembler:Assembler )
      assembler.write( Opcode.PEEK_CH_COUNT )
endClass

class CmdPeekChInt32( t, lookahead:Int32 ) : Cmd
  METHODS
    method to->String
      return "ch = peek($)" (lookahead)

    method write( assembler:Assembler )
      assembler.write( Opcode.PEEK_CH_INT32, lookahead )
endClass

class CmdConsume : Cmd
  METHODS
    method to->String
      return "consume"

    method write( assembler:Assembler )
      assembler.write( Opcode.CONSUME )
endClass

class CmdConsumeCharacter( t, value:Int32 ) : Cmd
  METHODS
    method jump_if_true->Opcode
      return Opcode.JUMP_GT

    method to->String
      return "consume($)" (value->Character.to_escaped_ascii)

    method write( assembler:Assembler )
      assembler.write( Opcode.CONSUME_CHARACTER, value )
endClass

class CmdConsumeString( t, value:String ) : Cmd
  METHODS
    method jump_if_true->Opcode
      return Opcode.JUMP_GT

    method to->String
      return "consume($)" (value.to_escaped_ascii)

    method write( assembler:Assembler )
      assembler.write( Opcode.CONSUME_STRING, value )
endClass

class CmdLiteralString( t, value:String ) : Cmd
  METHODS
    method init( t )
      value = t.text

    method to->String
      return ''"$"'' (value.to_escaped_ascii)

    method write( assembler:Assembler )
      throw t.error( "Syntax error - unexpected literal string." )
endClass

class CmdScanTable : Cmd
  PROPERTIES
    start = ScanNode()

  METHODS
    method init( t )
      start.is_acceptable = true

    method write( assembler:Assembler )
      assembler.write( Opcode.SCAN_TABLE )
      # Write twice - the first time through will set the correct addresses
      # and the second time through will use correct addresses.
      local start_ip = assembler.code.count
      local label_end = Label()
      start.write( assembler )                # set addresses
      assembler.code.discard_from( start_ip ) # reset
      start.write( assembler, label_end )     # set addresses
      assembler.define( label_end )
endClass

class ScanNode
  PROPERTIES
    is_acceptable : Logical
    address       : Int32
    links         = Table<<Character,ScanNode>>()
    statements    = CmdStatements()

  METHODS
    method link( ch:Character )->ScanNode
      local entry = links.find( ch )
      if (entry)
        return entry.value
      else
        local result = ScanNode()
        links[ ch ] = result
        return result
      endIf

    method write( assembler:Assembler, label_end=null:Label )
      address = assembler.code.count
      if (statements.count) is_acceptable = true
      assembler.write( select{is_acceptable:1 || 0} )

      # Write links
      assembler.write( links.count )
      forEach (key in links.keys)
        assembler.write( key->Int32 )
        assembler.write( links[key].address )
      endForEach

      # Write code
      statements.write( assembler )
      if (is_acceptable)
        assembler.write( Opcode.JUMP )
        if (label_end) assembler.write_address( label_end )
        else           assembler.write( 0 )  # end ip unknown on first pass
      endIf

      # Write subnode definitions
      (forEach in links).write( assembler, label_end )

    method to->String
      return "$$" (address->String,links)
endClass

