Launcher( System.command_line_arguments )

class Launcher
  METHODS
    method init( args:String[] )
      local filepaths = String[]
      local arg_reader = args.reader
      while (arg_reader.has_another)
        local arg = arg_reader.read
        filepaths.add( arg )
      endWhile

      if (filepaths.count == 0) println "No input files specified."

      ScanTableMaker( forEach in filepaths )
endClass

class ScanTableMaker
  PROPERTIES
    source : String
    reader : Scanner

    patterns            = StringTable<<Pattern>>()
    whitespace_patterns = Pattern[]
    token_names         = String[]
    token_types         = StringTable<<Int32>>()

  METHODS
    method init( filepath:String )
      init( filepath, File.load_as_string(filepath) )

    method init( filepath:String, source )
      try
        SourcePos.filepath = filepath
        SourcePos.source = source

        patterns//any = AnyCharacterPattern(SourcePos(0,0))

        reader = Scanner( source, &spaces_per_tab=4 )

        while (parse_section) noAction
        if (reader.has_another) throw source_pos.error( "Syntax error - unexpected character: $" (reader.read) )

        local tree = build_tree
        tree.tokenize( "Test", "Frley" )

      catch (error:FroleyError)
        println error->String
        System.exit 1
      endTry

    method build_tree->ScanTree
      local tree = ScanTree()
      forEach (token_name in token_names)
        local pattern = patterns[ token_name ]
        pattern = pattern.resolved( this )
        pattern.apply( this, tree.start, token_types[token_name] )
        #pattern.build_tree( this, tree, tree.start )
        #pattern.add( this, tree, tree.start, null, ScanNode.ACTION_ACCEPT, token_types[token_name] )
      endForEach
      tree.start.action = ScanNode.ACTION_NONE
      return tree

    method consume( ch:Character )->Logical [macro]
      return this.reader.consume( ch )

    method consume_eols->Logical
      local found_any = false
      while (consume('\n')) found_any = true
      return found_any

    method consume_whitespace->Logical
      local found_any = false
      while (consume(' ')) found_any=true
      return found_any

    method consume_whitespace_and_comments->Logical
      local found_any = false
      loop
        if (consume_whitespace) found_any=true; nextIteration
        if (consume('#'))
          found_any = true
          while (reader.has_another)
            if (reader.read == '\n') escapeWhile
          endWhile
          nextIteration
        endIf
        return found_any
      endLoop

    method consume_whitespace_comments_and_eols->Logical
      local found_any = false
      while (consume_whitespace_and_comments or consume('\n')) found_any = true
      return found_any

    method must_consume( ch:Character )
      if (consume(ch)) return
      throw source_pos.error( "'$' expected." (ch) )

    method must_consume_eols
      consume_whitespace_and_comments
      if (not consume('\n')) throw source_pos.error( "End of line expected." )
      while (consume_whitespace_comments_and_eols) noAction

    method parse_section->Logical
      while (consume_whitespace_and_comments or consume('\n')) noAction
      if (not reader.has_another) return false

      if (reader.consume("[whitespace]"))
        must_consume_eols
        consume_whitespace_comments_and_eols
        while (reader.has_another and reader.peek != '[')
          whitespace_patterns.add( parse_definition )
          must_consume_eols
        endWhile
        return true
      endIf

      if (reader.consume("[patterns]"))
        must_consume_eols
        while (reader.has_another and reader.peek != '[')
          local sp = source_pos
          local name = read_identifier
          consume_whitespace
          local pattern = parse_definition
          must_consume_eols
          if (patterns.contains(name)) throw sp.error( ''A definition for "$" already exists.''(name) )
          patterns[ name ] = pattern
        endWhile
        return true
      endIf

      if (reader.consume("[tokens]"))
        must_consume_eols
        while (reader.has_another and reader.peek != '[')
          local sp = source_pos
          local name = read_identifier
          consume_whitespace
          local pattern = parse_definition
          must_consume_eols
          if (patterns.contains(name)) throw sp.error( ''A definition for "$" already exists.''(name) )
          patterns[ name ] = pattern
          token_names.add( name )
          token_types[ name ] = token_names.count
        endWhile
        return true
      endIf

      return false


    method parse_pattern->Pattern
      local group = PatternGroup( source_pos )
      must_consume( '{' )
      consume_whitespace
      while (reader.has_another and peek != '}')
        group.add( parse_or )
        while (consume_whitespace or consume_eols) noAction
      endWhile
      must_consume( '}' )
      return group

    method parse_or->Pattern
      consume_whitespace
      return parse_zero_or_more

    method parse_zero_or_more->Pattern
      local pattern = parse_definition
      local sp = source_pos
      if (consume('*'))
        return ZeroOrMorePattern( sp, pattern )
      else
        return pattern
      endIf

    method parse_definition->Pattern
      consume_whitespace_and_comments
      which (reader.peek)
        case '{'
          return parse_pattern
        others
          return parse_string
      endWhich

    method parse_string->Pattern
      local sp = source_pos
      use builder = StringBuilder.pool
        if (reader.peek == '"' or reader.peek == '\'')
          local terminator = read
          while (reader.has_another and not consume(terminator))
            local ch = read
            builder.print( ch )
          endWhile
          if (builder.count == 0) throw sp.error( "Strings must contain at least one character." )
          return LiteralStringPattern( sp, builder->String )
        else
          while (reader.has_another)
            which (peek)
              case ' ', '\n', '#', '|','}','*','+'
                escapeWhile
              case '.'
                if (reader.peek(1) == '.') escapeWhile   # .. token
            endWhich
            builder.print( read )
          endWhile
          if (builder.count == 0) throw sp.error( "Pattern or literal character sequence expected." )
          return IdentifierPattern( sp, builder->String )
        endIf
      endUse
      return null  # never happens

    method peek->Character [macro]
      return this.reader.peek

    method read->Character [macro]
      return this.reader.read

    method read_identifier->String
      local id = reader.scan_identifier
      if (id) return id
      throw source_pos.error( "Identifier expected." )

    method source_pos->SourcePos
      return SourcePos( reader.line, reader.column )

endClass

class SourcePos( line=0:Int32, column=0:Int32 ) [compound]
  GLOBAL PROPERTIES
    filepath       : String
    source         : String

  METHODS
    method error( message:String )->FroleyError
      return FroleyError( message, filepath, source, line, column )
endClass

class FroleyError( message:String, filepath:String, source:String, line=0:Int32, column=0:Int32 ) : Error
  METHODS
    method to->String
      local builder = StringBuilder()
      local m = message.word_wrap(79,",").join
      if (filepath)
        builder.println( "=" * ((Console.width-1).or_smaller(79)) )
        builder.print( ''ERROR in "'' ).print( File.filename(filepath) )
        if (line) builder.print( ''" line '' ).print( line ).print( ", column " ).println( column )
        builder.println
        builder.println( m )

        if (line and source)
          builder.println
          forEach (line at index in LineReader(source))
            if (index+1 == this.line)
              builder.println( line )
              escapeForEach
            endIf
          endForEach
          builder.print( " " * (column-1) ).println( '^' )
        endIf

        builder.println( "=" * ((Console.width-1).or_smaller(79)) )
      else
        builder.println( "=" * ((Console.width-1).or_smaller(79)) )
        builder.println( "ERROR" )
        builder.println( m )
        builder.println( "=" * ((Console.width-1).or_smaller(79)) )
      endIf
      return builder->String
endClass

class Pattern( sp:SourcePos )
  PROPERTIES
    next : Pattern

  METHODS
    method apply( maker:ScanTableMaker, cur:ScanNode, token_type:Int32 )
      throw UnsupportedOperationError()

    method error( message:String )->FroleyError
      return sp.error( message )

    method resolved( maker:ScanTableMaker )->Pattern
      throw UnsupportedOperationError()

endClass

class AnyCharacterPattern : Pattern
  METHODS
    method apply( maker:ScanTableMaker, cur:ScanNode, token_type:Int32 )
      local node = cur.link_default
      if (next) next.apply( maker, node, token_type )
      else      node.accept( token_type )

    method resolved( maker:ScanTableMaker )->Pattern
      return AnyCharacterPattern(sp)

    method to->String
      return "(any)"
endClass

class ZeroOrMorePattern( sp, pattern:Pattern ) : Pattern
  METHODS
    #{
    method apply( maker:ScanTableMaker, cur:ScanNode, token_type:Int32 )
      local first = cur
      local last = ScanNode()
      local actual_next = next
      local next = last
      }#

    method resolved( maker:ScanTableMaker )->Pattern
      return ZeroOrMorePattern( sp, pattern.resolved(maker) )
endClass

class PatternGroup( sp ) : Pattern
  PROPERTIES
    elements = Pattern[]

  METHODS
    method add( pattern:Pattern )
      elements.add( pattern )

    method resolved( maker:ScanTableMaker )->Pattern
      local head, tail : Pattern
      forEach (element in elements)
        element = element.resolved( maker )
        if (head)
          tail.next = element
        else
          head = element
          tail = element
        endIf
        while (tail.next) tail = tail.next
      endForEach
      return head
endClass

class IdentifierPattern( sp, value:String ) : Pattern
  METHODS
    method resolved( maker:ScanTableMaker )->Pattern
      local pattern = maker.patterns[ value ]
      if (pattern)
        return pattern.resolved( maker )
      else
        return LiteralStringPattern( sp, value )
      endIf
endClass

class LiteralStringPattern( sp, value:String ) : Pattern
  METHODS
    method apply( maker:ScanTableMaker, cur:ScanNode, token_type:Int32 )
      forEach (ch in value)
        cur = cur.link( ch )
      endForEach
      if (next) next.apply( maker, cur, token_type )
      else      cur.accept( token_type )

    method resolved( maker:ScanTableMaker )->Pattern
      return LiteralStringPattern( sp, value )
endClass

class ScanTree
  PROPERTIES
    start  = ScanNode()
    buffer = StringBuilder()

  METHODS
    method tokenize( filepath:String, source:String )
      local reader = Scanner( source, &spaces_per_tab=4 )
      local cur = start
      buffer.clear
      while (reader.has_another)
        local ch = reader.peek
        local link = cur.on[ ch ]
        if (link)
          buffer.print( reader.read )
          cur = link
        elseIf (cur.on_alpha and ((ch>='a' and ch<='z') or (ch>='A' and ch<='Z')))
          buffer.print( reader.read )
          cur = cur.on_alpha
        elseIf (cur.on_digit and (ch>='0' and ch<='9'))
          buffer.print( reader.read )
          cur = cur.on_digit
        elseIf (cur.on_default)
          buffer.print( reader.read )
          cur = cur.on_default
        elseIf (cur.action)
          which (cur.action)
            case ScanNode.ACTION_ACCEPT
              accept( cur.token_type )
            case ScanNode.ACTION_ACCEPT_AND_DISCARD
              noAction
            case ScanNode.ACTION_ACCEPT_AND_CONVERT_TO_CHARACTER
              throw Error( "TODO" )
            case ScanNode.ACTION_ACCEPT_AND_CONVERT_TO_STRING
              throw Error( "TODO" )
          endWhich
          buffer.clear
          cur = start
        else
          throw FroleyError( "Syntax error - unexpected '$'."(reader.peek), filepath, source, reader.line, reader.column )
        endIf
      endWhile

      if (cur is not start)
        which (cur.action)
          case ScanNode.ACTION_NONE
            throw FroleyError( "Syntax error - unexpected end of input.", filepath, source, reader.line, reader.column )
          case ScanNode.ACTION_ACCEPT
            accept( cur.token_type )
          case ScanNode.ACTION_ACCEPT_AND_DISCARD
            noAction
          case ScanNode.ACTION_ACCEPT_AND_CONVERT_TO_CHARACTER
            throw Error( "TODO" )
          case ScanNode.ACTION_ACCEPT_AND_CONVERT_TO_STRING
            throw Error( "TODO" )
        endWhich
      endIf

    method accept( token_type:Int32 )
      trace token_type, buffer

endClass

class ScanNode
  ENUMERATE
    ACTION_NONE
    ACTION_ACCEPT
    ACTION_ACCEPT_AND_DISCARD
    ACTION_ACCEPT_AND_CONVERT_TO_CHARACTER
    ACTION_ACCEPT_AND_CONVERT_TO_STRING

  PROPERTIES
    action     : Int32
    token_type : Int32
    on         = Table<<Character,ScanNode>>()
    on_alpha   : ScanNode
    on_digit   : ScanNode
    on_default : ScanNode

  METHODS
    method accept( token_type, action=ScanNode.ACTION_ACCEPT )

    method link( ch:Character )->ScanNode
      local result = on[ ch ]
      if (not result)
        ensure result
        on[ ch ] = result
      endIf
      return result

    method link_alpha->ScanNode
      ensure on_alpha
      return on_alpha

    method link_digit->ScanNode
      ensure on_digit
      return on_digit

    method link_default->ScanNode
      ensure on_default
      return on_default
endClass

