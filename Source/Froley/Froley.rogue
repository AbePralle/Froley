Launcher( System.command_line_arguments )

class Launcher
  METHODS
    method init( args:String[] )
      local filepaths = String[]
      local arg_reader = args.reader
      while (arg_reader.has_another)
        local arg = arg_reader.read
        filepaths.add( arg )
      endWhile

      if (filepaths.count == 0) println "No input files specified."

      ScanTableMaker( forEach in filepaths )
endClass

class ScanTableMaker
  PROPERTIES
    source : String
    reader : Scanner

    patterns            = StringTable<<Pattern>>()
    token_names         = String[]
    token_types         = StringTable<<Int32>>()
    whitespace          = Character[]

    expanding_patterns  = Pattern[]

  METHODS
    method init( filepath:String )
      init( filepath, File.load_as_string(filepath) )

    method init( filepath:String, source )
      try
        SourcePos.filepath = filepath
        SourcePos.source = source

        patterns//any = AnyCharacterPattern(SourcePos(0,0))

        reader = Scanner( source, &spaces_per_tab=4 )

        while (parse_section) noAction
        if (reader.has_another)
          throw source_pos.error( "Syntax error - unexpected character: $" (reader.read.to_printable_string) )
        endIf

        local graph = build_graph
        graph.tokenize( File("Test.txt") )

      catch (error:FroleyError)
        println error->String
        System.exit 1
      endTry

    method build_graph->ScanGraph
      local graph = ScanGraph( whitespace )
      local sequence = Pattern[]
      forEach (token_name in token_names)
        local pattern = patterns[ token_name ]
        pattern = pattern.cloned( this )
        pattern.collect( this, sequence.clear )
        if (sequence.count)
          forEach (element at index in sequence)
            sequence[ index ] = element.cloned( this )
          endForEach
          local action = ScanState.ACTION_ACCEPT
          local token_type = token_types[ token_name ]
          local reader = PatternReader( this, graph, sequence, action, token_type )
          if (reader.has_another)
            reader.read.build_graph( graph.start, reader )
          endIf
        endIf
      endForEach
      return graph

    method consume( ch:Character )->Logical [macro]
      return this.reader.consume( ch )

    method consume_eols->Logical
      local found_any = false
      while (consume('\n')) found_any = true
      return found_any

    method consume_whitespace->Logical
      local found_any = false
      while (consume(' ')) found_any=true
      return found_any

    method consume_whitespace_and_comments->Logical
      local found_any = false
      loop
        if (consume_whitespace) found_any=true; nextIteration
        if (consume('#'))
          found_any = true
          while (reader.has_another)
            if (reader.read == '\n') escapeWhile
          endWhile
          nextIteration
        endIf
        return found_any
      endLoop

    method consume_whitespace_comments_and_eols->Logical
      local found_any = false
      while (consume_whitespace_and_comments or consume('\n')) found_any = true
      return found_any

    method must_consume( ch:Character )
      if (consume(ch)) return
      throw source_pos.error( "'$' expected." (ch) )

    method must_consume_eols
      consume_whitespace_and_comments
      if (not consume('\n')) throw source_pos.error( "End of line expected." )
      while (consume_whitespace_comments_and_eols) noAction

    method parse_section->Logical
      while (consume_whitespace_and_comments or consume('\n')) noAction
      if (not reader.has_another) return false

      if (reader.consume("[whitespace]"))
        must_consume_eols
        consume_whitespace_comments_and_eols
        while (reader.has_another and reader.peek != '[')
          local st = read_string
          forEach (ch in st) whitespace.add( ch )
          consume_whitespace_comments_and_eols
        endWhile
        forEach (ch in whitespace) trace ch->Int32
        return true
      endIf

      if (reader.consume("[definitions]"))
        must_consume_eols
        local name = parse_definition
        while (name)
          name = parse_definition
        endWhile
        return true
      endIf

      if (reader.consume("[tokens]"))
        must_consume_eols
        local name = parse_definition
        while (name)
          token_names.add( name )
          token_types[ name ] = token_names.count
          name = parse_definition
        endWhile
        return true
      endIf

      return false

    method parse_definition->String
      # Returns: name
      local name : String
      consume_eols
      if (reader.has_another and reader.peek != '[')
        local sp = source_pos
        name = read_identifier
        consume_whitespace
        local pattern : Pattern
        if (consume_eols)
          pattern = StringPattern( sp, name )
        else
          pattern = parse_pattern
          consume_whitespace
          must_consume_eols
        endIf
        if (patterns.contains(name)) throw sp.error( ''A definition for "$" already exists.''(name) )
        patterns[ name ] = pattern
        consume_whitespace_comments_and_eols
      endIf
      return name

    method parse_or->Pattern
      local pattern = parse_range : Pattern
      consume_whitespace
      local sp = source_pos
      if (consume('|'))
        local result = OrPattern( sp, pattern, parse_range )
        consume_whitespace
        while (consume('|'))
          result.add( parse_range )
          consume_whitespace
        endWhile
        return result
      else
        return pattern
      endIf

    method parse_range->Pattern
      local first = parse_zero_or_more
      if (reader.peek(0) == '.' and reader.peek(1) == '.')
        local sp = source_pos
        read
        read
        local last  = parse_zero_or_more
        if (first instanceOf IdentifierPattern)
          local first_id = first as IdentifierPattern
          if (first_id.value.count == 1) first = CharacterPattern( first.sp, first_id.value[0] )
        endIf
        local first_ch = first as CharacterPattern
        if (not first_ch)
          throw first.error( "Single character or Unicode value required for range." )
        endIf
        if (last instanceOf IdentifierPattern)
          local last_id = last as IdentifierPattern
          if (last_id.value.count == 1) last = CharacterPattern( last.sp, last_id.value[0] )
        endIf
        local last_ch = last as CharacterPattern
        if (not last_ch)
          throw last.error( "Single character or Unicode value required for range." )
        endIf
        local result = OrPattern( sp )
        forEach (ch in first_ch.value..last_ch.value)
          result.add( CharacterPattern(sp,ch) )
        endForEach
        return result
      else
        return first
      endIf

    method parse_zero_or_more->Pattern
      local pattern = parse_pattern
      local sp = source_pos
      if (consume('*'))
        return ZeroOrMorePattern( sp, pattern )
      else
        return pattern
      endIf

    method parse_pattern->Pattern
      consume_whitespace_and_comments
      which (reader.peek)
        case '('
          local group = PatternGroup( source_pos )
          must_consume( '(' )
          consume_whitespace
          while (reader.has_another and peek != ')')
            group.add( parse_or )
            while (consume_whitespace or consume_eols) noAction
          endWhile
          must_consume( ')' )
          return group
        others
          return parse_term
      endWhich

    method parse_term->Pattern
      local sp = source_pos
      if (reader.peek == '"' or reader.peek == '\'')
        local st = read_string
        if (st.count == 0) throw sp.error( "Strings must contain at least one character." )
        if (st.count == 1) return CharacterPattern( sp, st[0] )
        return StringPattern( sp, st )
      else
        use builder = StringBuilder.pool
          local all_digits = true
          while (reader.has_another)
            which (peek)
              case ' ', '\t', '\n', '#', '|',')','*','+'
                escapeWhile
              case '.'
                if (reader.peek(1) == '.') escapeWhile   # .. token
            endWhich
            local ch = read
            builder.print( ch )
            if (ch < '0' or ch > '9') all_digits = false
          endWhile
          if (builder.count == 0) throw sp.error( "Pattern or literal character sequence expected." )
          if (all_digits) return CharacterPattern( sp, builder->String->Int32->Character )
          return IdentifierPattern( sp, builder->String )
        endUse
      endIf
      return null  # never happens

    method read_string->String
      use builder = StringBuilder.pool
        if (reader.peek == '"' or reader.peek == '\'')
          local terminator = read
          while (reader.has_another and not consume(terminator))
            local ch = read_character
            builder.print( ch )
          endWhile
          return builder->String
        else
          local all_digits = true
          while (reader.has_another)
            which (peek)
              case ' ', '\t', '\n', '#'
                escapeWhile
            endWhich
            local ch = read
            builder.print( ch )
            if (ch < '0' or ch > '9') all_digits = false
          endWhile
          if (all_digits) return ""+builder->String->Int32->Character
          return builder->String
        endIf
      endUse
      return null  # never happens

    method read_character->Character
      local sp = source_pos
      local ch = read
      if (ch == '\\')
        ch = read
        which (ch)
          case 'b':  return 8->Character
          case 'e':  return 27->Character
          case 'f':  return 12->Character
          case 'n':  return '\n'
          case 'r':  return '\r'
          case 't':  return '\t'
          case 'v':  return 11->Character
          case '0':  return '\0'
          case '/':  return '/'
          case '?':  return '?'
          case '\'': return '\''
          case '\\': return '\\'
          case '"':  return '"'
          others
            throw sp.error( ''Invalid escape sequence.  Supported: \\b \\e \\f \\n \\r \\t \\v \\0 \\? \\/ \\' \\\\ \\\"'' )
        endWhich
      else
        return ch
      endIf


    method peek->Character [macro]
      return this.reader.peek

    method read->Character [macro]
      return this.reader.read

    method read_identifier->String
      local id = reader.scan_identifier
      if (id) return id
      throw source_pos.error( "Identifier expected." )

    method source_pos->SourcePos
      return SourcePos( reader.line, reader.column )

endClass

class SourcePos( line=0:Int32, column=0:Int32 ) [compound]
  GLOBAL PROPERTIES
    filepath       : String
    source         : String

  METHODS
    method error( message:String )->FroleyError
      return FroleyError( message, filepath, source, line, column )
endClass

class FroleyError( message:String, filepath:String, source:String, line=0:Int32, column=0:Int32 ) : Error
  METHODS
    method to->String
      local builder = StringBuilder()
      local m = message.word_wrap(79,",").join
      if (filepath)
        builder.println( "=" * ((Console.width-1).or_smaller(79)) )
        builder.print( ''ERROR in "'' ).print( File.filename(filepath) )
        if (line) builder.print( ''" line '' ).print( line ).print( ", column " ).println( column )
        builder.println
        builder.println( m )

        if (line and source)
          builder.println
          forEach (line at index in LineReader(source))
            if (index+1 == this.line)
              builder.println( line )
              escapeForEach
            endIf
          endForEach
          builder.print( " " * (column-1) ).println( '^' )
        endIf

        builder.println( "=" * ((Console.width-1).or_smaller(79)) )
      else
        builder.println( "=" * ((Console.width-1).or_smaller(79)) )
        builder.println( "ERROR" )
        builder.println( m )
        builder.println( "=" * ((Console.width-1).or_smaller(79)) )
      endIf
      return builder->String
endClass

class PatternReader
  PROPERTIES
    maker      : ScanTableMaker
    graph      : ScanGraph
    sequence   : Pattern[]
    stack      : Pattern[]
    position   : Int32
    action     : Int32
    action_arg : Int32

  METHODS
    method init( maker, graph, sequence, action, action_arg, position=0, stack=null )

    method accept( state:ScanState )
      state.accept( action, action_arg )

    method cloned->PatternReader
      local new_stack = select{ stack:stack.cloned || null } : Pattern[]
      return PatternReader( maker, graph, sequence, action, action_arg, position, new_stack )

    method empty_clone->PatternReader
      return PatternReader( maker, graph, Pattern[], ScanState.ACTION_NONE, 0, 0, null )

    method has_another->Logical
      return (stack and stack.count) or position < sequence.count

    method peek->Pattern
      if (stack and stack.count) return stack.last
      return sequence[ position ]

    method push( pattern:Pattern )
      ensure stack
      stack.add( pattern )

    method read->Pattern
      if (stack and stack.count) return stack.remove_last
      ++position
      return sequence[ position-1 ]

    method to->String
      return sequence.subset( position )->String
endClass


class Pattern( sp:SourcePos )
  PROPERTIES
    state : ScanState

  METHODS
    method build_graph( previous:ScanState, reader:PatternReader )
      throw UnsupportedOperationError()

    method cloned( maker:ScanTableMaker )->Pattern
      throw UnsupportedOperationError()

    method collect( maker:ScanTableMaker, sequence:Pattern[] )
      sequence.add( this )

    method error( message:String )->FroleyError
      return sp.error( message )

    method set_last_state( state:ScanState )
      this.state = state
endClass


class AnyCharacterPattern : Pattern
  METHODS
    method build_graph( previous:ScanState, reader:PatternReader )
      state = previous.link_default
      if (reader.has_another) reader.read.build_graph( state, reader )
      else                    reader.accept( state )

    method cloned( maker:ScanTableMaker )->Pattern
      return AnyCharacterPattern( sp )

    method to->String
      return "(any)"
endClass


class ZeroOrMorePattern( sp, sub_pattern:Pattern ) : Pattern
  METHODS
    method build_graph( previous:ScanState, reader:PatternReader )
      sub_pattern.set_last_state( previous )
      sub_pattern.build_graph( previous, reader.empty_clone )
      if (reader.has_another)
        reader.read.build_graph( previous, reader )
      else
        reader.accept( previous )
      endIf

    method cloned( maker:ScanTableMaker )->Pattern
      return ZeroOrMorePattern( sp, sub_pattern.cloned(maker) )

    method set_last_state( state:ScanState )
      this.state = state
      sub_pattern.set_last_state( state )

    method to->String
      return sub_pattern->String + "*"
endClass


class PatternGroup( sp ) : Pattern
  PROPERTIES
    elements = Pattern[]

  METHODS
    method add( pattern:Pattern )
      elements.add( pattern )

    method build_graph( previous:ScanState, reader:PatternReader )
      forEach (element in elements step -1) reader.push( element )
      if (reader.has_another) reader.read.build_graph( previous, reader )
      else                    reader.accept( previous )

    method cloned( maker:ScanTableMaker )->Pattern
      local result = PatternGroup( sp )
      forEach (element at index in elements)
        result.add( element.cloned(maker) )
      endForEach
      return result

    method set_last_state( state:ScanState )
      if (elements.count) elements.last.set_last_state( state )

    method to->String
      return "($)" (elements.join(","))
endClass

class OrPattern : Pattern
  PROPERTIES
    elements = Pattern[]

  METHODS
    method init( sp )

    method init( sp, first:Pattern, second:Pattern )
      add( first )
      add( second )

    method add( pattern:Pattern )
      elements.add( pattern )

    method build_graph( previous:ScanState, reader:PatternReader )
      forEach (element in elements)
        element.build_graph( previous, reader.cloned )
      endForEach

    method cloned( maker:ScanTableMaker )->Pattern
      local result = OrPattern( sp )
      forEach (element at index in elements)
        result.add( element.cloned(maker) )
      endForEach
      return result

    method set_last_state( state:ScanState )
      (forEach in elements).set_last_state( state )

    method to->String
      return "[$]" (elements.join("|"))
endClass


class IdentifierPattern( sp, value:String ) : Pattern
  METHODS
    method cloned( maker:ScanTableMaker )->Pattern
      local pattern = maker.patterns[ value ]
      if (pattern)
        if (maker.expanding_patterns.contains(pattern)) throw sp.error( "Recursive pattern definition." )
        maker.expanding_patterns.add( pattern )
        pattern = pattern.cloned( maker )
        maker.expanding_patterns.remove_last
        return pattern
      else
        if (value.count == 1) return CharacterPattern( sp, value[0] )
        return StringPattern( sp, value ).cloned( maker )
      endIf
endClass

class CharacterPattern( sp, value:Character ) : Pattern
  METHODS
    method build_graph( previous:ScanState, reader:PatternReader )
      state = previous.link( value, state )
      if (reader.has_another) reader.read.build_graph( state, reader )
      else                    reader.accept( state )

    method cloned( maker:ScanTableMaker )->Pattern
      return CharacterPattern( sp, value )

    method to->String
      return "'$'" (value)
endClass

class StringPattern( sp, value:String ) : Pattern
  METHODS
    method build_graph( previous:ScanState, reader:PatternReader )
      forEach (ch in value step -1)
        reader.push( CharacterPattern(sp,ch) )
      endForEach
      if (reader.has_another) reader.read.build_graph( previous, reader )
      else                    reader.accept( previous )

    method cloned( maker:ScanTableMaker )->Pattern
      local result = PatternGroup( sp )
      forEach (ch in value)
        result.add( CharacterPattern( sp, ch ) )
      endForEach
      return result

    method to->String
      return ''"$"'' (value)
endClass

class ScanGraph
  PROPERTIES
    whitespace    : Character[]
    start         = ScanState()
    buffer        = StringBuilder()
    strings       = StringLookupList()

  METHODS
    method init( whitespace )

    method tokenize( file:File )
      tokenize( file.filepath, file.load_as_string )

    method tokenize( filepath:String, source:String )
      local reader = Scanner( source, &spaces_per_tab=4 )
      local cur = start
      buffer.clear
      consume_whitespace( reader )
      while (reader.has_another)
        local ch = reader.peek
        local link = cur.on[ ch ]
        if (link)
          buffer.print( reader.read )
          cur = link
        elseIf (cur.on_default)
          buffer.print( reader.read )
          cur = cur.on_default
        elseIf (cur.action)
          which (cur.action)
            case ScanState.ACTION_ACCEPT
              accept( cur.action_arg )
          endWhich
          buffer.clear
          cur = start
          consume_whitespace( reader )
        else
          throw FroleyError( "Syntax error - unexpected '$'."(reader.peek.to_printable_string), filepath, source, reader.line, reader.column )
        endIf
      endWhile

      if (cur is not start)
        which (cur.action)
          case ScanState.ACTION_NONE
            throw FroleyError( "Syntax error - unexpected end of input.", filepath, source, reader.line, reader.column )
          case ScanState.ACTION_ACCEPT
            accept( cur.action_arg )
        endWhich
      endIf

    method accept( token_type:Int32 )
      trace token_type, buffer

    method consume_whitespace( reader:Scanner )
      while (whitespace.contains(reader.peek)) reader.read

endClass

class ScanState
  ENUMERATE
    ACTION_NONE
    ACTION_ACCEPT

  PROPERTIES
    action     : Int32
    action_arg : Int32
    token_type : Int32
    on         = Table<<Character,ScanState>>()
    on_default : ScanState

  METHODS
    method accept( action, token_type )

    method link( ch:Character, state:ScanState )->ScanState
      local result = on[ ch ]
      if (not result)
        result = state
        ensure result
        on[ ch ] = result
      endIf
      return result

    method link_default->ScanState
      ensure on_default
      return on_default
endClass

