Launcher( System.command_line_arguments )

class Launcher
  METHODS
    method init( args:String[] )
      local filepaths = String[]
      local arg_reader = args.reader
      while (arg_reader.has_another)
        local arg = arg_reader.read
        filepaths.add( arg )
      endWhile

      if (filepaths.count == 0) println "No input files specified."

      ScanTableMaker( forEach in filepaths )
endClass

class ScanTableMaker
  PROPERTIES
    source : String
    reader : Scanner

    patterns            = StringTable<<Pattern>>()
    whitespace_patterns = Pattern[]
    token_names         = String[]
    token_types         = StringTable<<Int32>>()

    expanding_patterns  = Pattern[]

  METHODS
    method init( filepath:String )
      init( filepath, File.load_as_string(filepath) )

    method init( filepath:String, source )
      try
        SourcePos.filepath = filepath
        SourcePos.source = source

        patterns//any = AnyCharacterPattern(SourcePos(0,0))

        reader = Scanner( source, &spaces_per_tab=4 )

        while (parse_section) noAction
        if (reader.has_another) throw source_pos.error( "Syntax error - unexpected character: $" (reader.read) )

        local graph = build_graph
        graph.tokenize( "Test", "Froooley" )

      catch (error:FroleyError)
        println error->String
        System.exit 1
      endTry

    method build_graph->ScanGraph
      local graph = ScanGraph()
      local sequence = Pattern[]
      forEach (token_name in token_names)
        local pattern = patterns[ token_name ]
        pattern = pattern.cloned( this )
        pattern.collect( this, sequence.clear )
        if (sequence.count)
          forEach (element at index in sequence)
            sequence[ index ] = element.cloned( this )
          endForEach
          local reader = PatternReader( this, graph, sequence, token_types[token_name] )
trace reader
          if (reader.has_another)
            reader.read.build_graph( graph.start, reader )
          endIf
        endIf
      endForEach
      return graph

    method consume( ch:Character )->Logical [macro]
      return this.reader.consume( ch )

    method consume_eols->Logical
      local found_any = false
      while (consume('\n')) found_any = true
      return found_any

    method consume_whitespace->Logical
      local found_any = false
      while (consume(' ')) found_any=true
      return found_any

    method consume_whitespace_and_comments->Logical
      local found_any = false
      loop
        if (consume_whitespace) found_any=true; nextIteration
        if (consume('#'))
          found_any = true
          while (reader.has_another)
            if (reader.read == '\n') escapeWhile
          endWhile
          nextIteration
        endIf
        return found_any
      endLoop

    method consume_whitespace_comments_and_eols->Logical
      local found_any = false
      while (consume_whitespace_and_comments or consume('\n')) found_any = true
      return found_any

    method must_consume( ch:Character )
      if (consume(ch)) return
      throw source_pos.error( "'$' expected." (ch) )

    method must_consume_eols
      consume_whitespace_and_comments
      if (not consume('\n')) throw source_pos.error( "End of line expected." )
      while (consume_whitespace_comments_and_eols) noAction

    method parse_section->Logical
      while (consume_whitespace_and_comments or consume('\n')) noAction
      if (not reader.has_another) return false

      if (reader.consume("[whitespace]"))
        must_consume_eols
        consume_whitespace_comments_and_eols
        while (reader.has_another and reader.peek != '[')
          whitespace_patterns.add( parse_definition )
          must_consume_eols
        endWhile
        return true
      endIf

      if (reader.consume("[patterns]"))
        must_consume_eols
        while (reader.has_another and reader.peek != '[')
          local sp = source_pos
          local name = read_identifier
          consume_whitespace
          local pattern = parse_definition
          must_consume_eols
          if (patterns.contains(name)) throw sp.error( ''A definition for "$" already exists.''(name) )
          patterns[ name ] = pattern
        endWhile
        return true
      endIf

      if (reader.consume("[tokens]"))
        must_consume_eols
        while (reader.has_another and reader.peek != '[')
          local sp = source_pos
          local name = read_identifier
          consume_whitespace
          local pattern = parse_definition
          must_consume_eols
          if (patterns.contains(name)) throw sp.error( ''A definition for "$" already exists.''(name) )
          patterns[ name ] = pattern
          token_names.add( name )
          token_types[ name ] = token_names.count
        endWhile
        return true
      endIf

      return false


    method parse_pattern->Pattern
      local group = PatternGroup( source_pos )
      must_consume( '{' )
      consume_whitespace
      while (reader.has_another and peek != '}')
        group.add( parse_or )
        while (consume_whitespace or consume_eols) noAction
      endWhile
      must_consume( '}' )
      return group

    method parse_or->Pattern
      consume_whitespace
      return parse_zero_or_more

    method parse_zero_or_more->Pattern
      local pattern = parse_definition
      local sp = source_pos
      if (consume('*'))
        return ZeroOrMorePattern( sp, pattern )
      else
        return pattern
      endIf

    method parse_definition->Pattern
      consume_whitespace_and_comments
      which (reader.peek)
        case '{'
          return parse_pattern
        others
          return parse_string
      endWhich

    method parse_string->Pattern
      local sp = source_pos
      use builder = StringBuilder.pool
        if (reader.peek == '"' or reader.peek == '\'')
          local terminator = read
          while (reader.has_another and not consume(terminator))
            local ch = read
            builder.print( ch )
          endWhile
          if (builder.count == 0) throw sp.error( "Strings must contain at least one character." )
          return LiteralStringPattern( sp, builder->String )
        else
          while (reader.has_another)
            which (peek)
              case ' ', '\n', '#', '|','}','*','+'
                escapeWhile
              case '.'
                if (reader.peek(1) == '.') escapeWhile   # .. token
            endWhich
            builder.print( read )
          endWhile
          if (builder.count == 0) throw sp.error( "Pattern or literal character sequence expected." )
          return IdentifierPattern( sp, builder->String )
        endIf
      endUse
      return null  # never happens

    method peek->Character [macro]
      return this.reader.peek

    method read->Character [macro]
      return this.reader.read

    method read_identifier->String
      local id = reader.scan_identifier
      if (id) return id
      throw source_pos.error( "Identifier expected." )

    method source_pos->SourcePos
      return SourcePos( reader.line, reader.column )

endClass

class SourcePos( line=0:Int32, column=0:Int32 ) [compound]
  GLOBAL PROPERTIES
    filepath       : String
    source         : String

  METHODS
    method error( message:String )->FroleyError
      return FroleyError( message, filepath, source, line, column )
endClass

class FroleyError( message:String, filepath:String, source:String, line=0:Int32, column=0:Int32 ) : Error
  METHODS
    method to->String
      local builder = StringBuilder()
      local m = message.word_wrap(79,",").join
      if (filepath)
        builder.println( "=" * ((Console.width-1).or_smaller(79)) )
        builder.print( ''ERROR in "'' ).print( File.filename(filepath) )
        if (line) builder.print( ''" line '' ).print( line ).print( ", column " ).println( column )
        builder.println
        builder.println( m )

        if (line and source)
          builder.println
          forEach (line at index in LineReader(source))
            if (index+1 == this.line)
              builder.println( line )
              escapeForEach
            endIf
          endForEach
          builder.print( " " * (column-1) ).println( '^' )
        endIf

        builder.println( "=" * ((Console.width-1).or_smaller(79)) )
      else
        builder.println( "=" * ((Console.width-1).or_smaller(79)) )
        builder.println( "ERROR" )
        builder.println( m )
        builder.println( "=" * ((Console.width-1).or_smaller(79)) )
      endIf
      return builder->String
endClass

class PatternReader
  PROPERTIES
    maker      : ScanTableMaker
    graph      : ScanGraph
    sequence   : Pattern[]
    stack      : Pattern[]
    position   : Int32
    token_type : Int32?

  METHODS
    method init( maker, graph, sequence, token_type, position=0, stack=null )

    method accept( state:ScanState )
      if (token_type.exists)
        state.accept( token_type.value )
      endIf

    method cloned->PatternReader
      local new_stack = select{ stack:stack.cloned || null } : Pattern[]
      return PatternReader( maker, graph, sequence, token_type, position, new_stack )

    method empty_clone->PatternReader
      return PatternReader( maker, graph, Pattern[], null, 0, null )

    method has_another->Logical
      return (stack and stack.count) or position < sequence.count

    method peek->Pattern
      if (stack and stack.count) return stack.last
      return sequence[ position ]

    method push( pattern:Pattern )
      ensure stack
      stack.add( pattern )

    method read->Pattern
      if (stack and stack.count) return stack.remove_last
      ++position
      return sequence[ position-1 ]

    method to->String
      return sequence.subset( position )->String
endClass


class Pattern( sp:SourcePos )
  PROPERTIES
    state : ScanState

  METHODS
    method build_graph( previous:ScanState, reader:PatternReader )
      throw UnsupportedOperationError()

    method cloned( maker:ScanTableMaker )->Pattern
      throw UnsupportedOperationError()

    method collect( maker:ScanTableMaker, sequence:Pattern[] )
      sequence.add( this )

    method error( message:String )->FroleyError
      return sp.error( message )

    method set_last_state( state:ScanState )
      this.state = state
endClass


class AnyCharacterPattern : Pattern
  METHODS
    method build_graph( previous:ScanState, reader:PatternReader )
      state = previous.link_default
      if (reader.has_another) reader.read.build_graph( state, reader )
      else                    reader.accept( state )

    method cloned( maker:ScanTableMaker )->Pattern
      return AnyCharacterPattern( sp )

    method to->String
      return "(any)"
endClass


class ZeroOrMorePattern( sp, sub_pattern:Pattern ) : Pattern
  METHODS
    method build_graph( previous:ScanState, reader:PatternReader )
      sub_pattern.set_last_state( previous )
      sub_pattern.build_graph( previous, reader.empty_clone )
      if (reader.has_another)
        reader.read.build_graph( previous, reader )
      else
        reader.accept( previous )
      endIf

    method cloned( maker:ScanTableMaker )->Pattern
      return ZeroOrMorePattern( sp, sub_pattern.cloned(maker) )

    method set_last_state( state:ScanState )
      this.state = state
      sub_pattern.set_last_state( state )

    method to->String
      return sub_pattern->String + "*"
endClass


class PatternGroup( sp ) : Pattern
  PROPERTIES
    elements = Pattern[]

  METHODS
    method add( pattern:Pattern )
      elements.add( pattern )

    method build_graph( previous:ScanState, reader:PatternReader )
      forEach (element in elements step -1) reader.push( element )
      if (reader.has_another) reader.read.build_graph( previous, reader )
      else                    reader.accept( previous )

    method cloned( maker:ScanTableMaker )->Pattern
      local result = PatternGroup( sp )
      forEach (element at index in elements)
        result.add( element.cloned(maker) )
      endForEach
      return result

    method set_last_state( state:ScanState )
      if (elements.count) elements.last.set_last_state( state )

    method to->String
      return "{$}" (elements->String.leftmost(-1).rightmost(-1))
endClass


class IdentifierPattern( sp, value:String ) : Pattern
  METHODS
    method cloned( maker:ScanTableMaker )->Pattern
      local pattern = maker.patterns[ value ]
      if (pattern)
        if (maker.expanding_patterns.contains(pattern)) throw sp.error( "Recursive pattern definition." )
        maker.expanding_patterns.add( pattern )
        pattern = pattern.cloned( maker )
        maker.expanding_patterns.remove_last
        return pattern
      else
        return LiteralStringPattern( sp, value ).cloned( maker )
      endIf
endClass

class LiteralCharacterPattern( sp, value:Character ) : Pattern
  METHODS
    method build_graph( previous:ScanState, reader:PatternReader )
      state = previous.link( value, state )
      if (reader.has_another) reader.read.build_graph( state, reader )
      else                    reader.accept( state )

    method cloned( maker:ScanTableMaker )->Pattern
      return LiteralCharacterPattern( sp, value )

    method to->String
      return "'$'" (value)
endClass

class LiteralStringPattern( sp, value:String ) : Pattern
  METHODS
    method build_graph( previous:ScanState, reader:PatternReader )
      forEach (ch in value step -1)
        reader.push( LiteralCharacterPattern(sp,ch) )
      endForEach
      if (reader.has_another) reader.read.build_graph( previous, reader )
      else                    reader.accept( previous )

    method cloned( maker:ScanTableMaker )->Pattern
      local result = PatternGroup( sp )
      forEach (ch in value)
        result.add( LiteralCharacterPattern( sp, ch ) )
      endForEach
      return result

    method to->String
      return ''"$"'' (value)
endClass

class ScanGraph
  PROPERTIES
    start  = ScanState()
    buffer = StringBuilder()

  METHODS
    method tokenize( filepath:String, source:String )
      local reader = Scanner( source, &spaces_per_tab=4 )
      local cur = start
      buffer.clear
      while (reader.has_another)
        local ch = reader.peek
        local link = cur.on[ ch ]
        if (link)
          buffer.print( reader.read )
          cur = link
        elseIf (cur.on_alpha and ((ch>='a' and ch<='z') or (ch>='A' and ch<='Z')))
          buffer.print( reader.read )
          cur = cur.on_alpha
        elseIf (cur.on_digit and (ch>='0' and ch<='9'))
          buffer.print( reader.read )
          cur = cur.on_digit
        elseIf (cur.on_default)
          buffer.print( reader.read )
          cur = cur.on_default
        elseIf (cur.action)
          which (cur.action)
            case ScanState.ACTION_ACCEPT
              accept( cur.token_type )
            case ScanState.ACTION_ACCEPT_AND_DISCARD
              noAction
            case ScanState.ACTION_ACCEPT_AND_CONVERT_TO_CHARACTER
              throw Error( "TODO" )
            case ScanState.ACTION_ACCEPT_AND_CONVERT_TO_STRING
              throw Error( "TODO" )
          endWhich
          buffer.clear
          cur = start
        else
trace cur.on.keys
          throw FroleyError( "Syntax error - unexpected '$'."(reader.peek), filepath, source, reader.line, reader.column )
        endIf
      endWhile

      if (cur is not start)
        which (cur.action)
          case ScanState.ACTION_NONE
            throw FroleyError( "Syntax error - unexpected end of input.", filepath, source, reader.line, reader.column )
          case ScanState.ACTION_ACCEPT
            accept( cur.token_type )
          case ScanState.ACTION_ACCEPT_AND_DISCARD
            noAction
          case ScanState.ACTION_ACCEPT_AND_CONVERT_TO_CHARACTER
            throw Error( "TODO" )
          case ScanState.ACTION_ACCEPT_AND_CONVERT_TO_STRING
            throw Error( "TODO" )
        endWhich
      endIf

    method accept( token_type:Int32 )
      trace token_type, buffer

endClass

class ScanState
  ENUMERATE
    ACTION_NONE
    ACTION_ACCEPT
    ACTION_ACCEPT_AND_DISCARD
    ACTION_ACCEPT_AND_CONVERT_TO_CHARACTER
    ACTION_ACCEPT_AND_CONVERT_TO_STRING

  PROPERTIES
    action     : Int32
    token_type : Int32
    on         = Table<<Character,ScanState>>()
    on_alpha   : ScanState
    on_digit   : ScanState
    on_default : ScanState

  METHODS
    method accept( token_type, action=ScanState.ACTION_ACCEPT )

    method link( ch:Character, state:ScanState )->ScanState
      local result = on[ ch ]
      if (not result)
        result = state
        ensure result
        on[ ch ] = result
      endIf
      return result

    method link_alpha->ScanState
      ensure on_alpha
      return on_alpha

    method link_digit->ScanState
      ensure on_digit
      return on_digit

    method link_default->ScanState
      ensure on_default
      return on_default
endClass

