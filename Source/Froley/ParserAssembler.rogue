module Froley
  uses ParseKit<<Froley>>

class ParserAssembler : Assembler
  DEFINITIONS
    VERSION = 1

  PROPERTIES
    this_method : ParserMethod
    cmd_types   = StringLookupList()

  METHODS
    method assemble( methods:LookupList<<ParserMethod>> )->Byte[]
      forEach (m in methods)
        m.write( this )
      endForEach
      write( ParserOpcode.SYNTAX_ERROR )
      return this->Byte[]

    method cmd_type_index( name:String )->Int32
      strings.add( name )
      return cmd_types.add( name )

    method to->Byte[]
      if (unresolved_labels.count)
        local labels = unresolved_labels
        throw FroleyError( "References to undefined $: $" ("label".pluralized(labels.count),labels.join(", ")) )
      endIf

      local result = Byte[]
      local writer = DataWriter( result )

      writer.write_int32x( VERSION )

      writer.write_int32x( strings.count )
      forEach (value in strings)
        writer.write_string( value )
      endForEach

      #{
      writer.write_int32x( Froley.entry_points.count )
      forEach (entry_point_name in Froley.entry_points)
        writer.write_int32x( strings.locate(entry_point_name).value )
        writer.write_int32x( label(entry_point_name).address.value )
      endForEach
      }#

      writer.write_int32x( code.count )
      forEach (value in code)
        writer.write_int32x( value )
      endForEach

      writer.close
      #trace code.count, " -> ", result.count
      return result

    method write( opcode:ParserOpcode ) [macro]
      this.write( opcode->Int32 )

    method write( opcode:ParserOpcode, value:Int32 )
      write( opcode->Int32 )
      write( value )

    method write( opcode:ParserOpcode, label:Label )
      write( opcode->Int32 )
      write_address( label )

    method write( opcode:ParserOpcode, value:String )
      write( opcode->Int32 )
      write( strings.add(value) )

endClass

