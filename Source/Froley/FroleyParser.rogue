module Froley
  uses ParseKit<<Froley>>

class FroleyParser : Parser
  PROPERTIES
    parse_expression : ParseRule

  METHODS
    method init
      # expression
      local rule = add( ParseRule("expression") )

      # assignment
      rule = add_nested( RightAssociativeBinaryParseRule("assignment") )
      rule.on( "=", <<CmdAssign>> )

      # comparison
      rule = add_nested( BinaryParseRule("comparison") )
      rule.on( "==", <<CmdCompareEQ>> )
      rule.on( "!=", <<CmdCompareNE>> )
      rule.on( "<",  <<CmdCompareLT>> )
      rule.on( "<=", <<CmdCompareLE>> )
      rule.on( ">",  <<CmdCompareGT>> )
      rule.on( ">=", <<CmdCompareGE>> )

      # term
      rule = add_nested( ParseRule("term") )
      rule.on( "(",
        function (parser:FroleyParser)->Cmd
          parser.must_consume( TokenType.SYMBOL_OPEN_PAREN )
          local result = parser.parse_expression()
          parser.must_consume( TokenType.SYMBOL_CLOSE_PAREN )
          return result
        endFunction
      )
      rule.on( "count",         <<CmdRegisterCount>> )
      rule.on( "hasAnother",    <<CmdHasAnother>> )
      rule.on( "identifier",    <<CmdAccess>> )
      rule.on( "integer value", <<CmdLiteralInt32>> )
      rule.on( "read",          <<CmdRead>> )
      rule.on( "ch",            <<CmdRegisterCh>> )
      rule.on( "scanDigits",
        function(parser:FroleyParser)->Cmd
          local t = parser.read  # 'scanDigits'
          local min_digits = parser.read_integer
          local max_digits = min_digits
          if (parser.consume(TokenType.SYMBOL_DOT_DOT)) max_digits = parser.read_integer
          local base = 10
          if (parser.consume(TokenType.KEYWORD_BASE))
            base = parser.read_integer
          endIf
          return CmdScanDigits(t,min_digits,max_digits,base)
        endFunction
      )

    method parse_statements( statements:CmdStatements )->Logical
      if (consume_eols)
        parse_multi_line_statements( statements )
        return true
      else
        parse_single_line_statements( statements )
        return false
      endIf

    method parse_multi_line_statements( statements:CmdStatements )
      consume_eols
      while (reader.has_another and not reader.peek.type.is_structural)
        parse_statement( statements, &allow_control_structures )
        while (consume_eols or consume(TokenType.SYMBOL_SEMICOLON)) noAction
      endWhile

    method parse_single_line_statements( statements:CmdStatements )
      while (reader.has_another and not reader.peek.type.is_structural)
        parse_statement( statements, &!allow_control_structures )
        if (not consume(TokenType.SYMBOL_SEMICOLON)) escapeWhile
        while (consume(TokenType.SYMBOL_SEMICOLON)) noAction

        # Don't let a trailing ';' act as a next-line continuation.
        if (next_is(TokenType.EOL)) escapeWhile
      endWhile

      if (not consume(TokenType.EOL))
        if (not reader.peek.type.is_structural)
          must_consume( TokenType.EOL )  # force an error
        endIf
      endIf

    method parse_statement( statements:CmdStatements, &allow_control_structures )->Logical
      consume_eols
      if (not has_another) return false
      local t = peek
      if (t.type.is_structural) return false

      if (allow_control_structures)
        if (consume(TokenType.KEYWORD_IF))
          local cmd_if = CmdIf( t, parse_expression() )
          if (parse_statements(cmd_if.statements))
            # Multi-line statements
            local outer_if = cmd_if
            while (next_is_else_if(&multi_line))
              local t2 = read
              local inner_if = CmdIf( t2, parse_expression() )
              parse_multi_line_statements( inner_if.statements )
              ensure outer_if.else_statements
              outer_if.else_statements.add( inner_if )
              outer_if = inner_if
            endWhile
            consume_eols
            if (next_is(TokenType.KEYWORD_ELSE) and reader.peek(1).type == TokenType.EOL)
              read
              ensure outer_if.else_statements
              parse_multi_line_statements( outer_if.else_statements )
            endIf
            must_consume( TokenType.KEYWORD_END_IF )
          else
            # Single line statements
            local outer_if = cmd_if
            while (next_is_else_if(&single_line))
              local t2 = read
              local inner_if = CmdIf( t2, parse_expression() )
              parse_single_line_statements( inner_if.statements )
              ensure outer_if.else_statements
              outer_if.else_statements.add( inner_if )
              outer_if = inner_if
            endWhile
            consume_eols
            if (next_is(TokenType.KEYWORD_ELSE) and reader.peek(1).type != TokenType.EOL)
              read
              ensure outer_if.else_statements
              parse_single_line_statements( outer_if.else_statements )
            endIf
          endIf
          statements.add( cmd_if )
          return true

        elseIf (consume(TokenType.KEYWORD_WHILE))
          local cmd_while = CmdWhile( t, parse_expression() )
          if (parse_statements(cmd_while.statements))
            # Returns true if multi-line statements were parsed
            must_consume( TokenType.KEYWORD_END_WHILE )
          endIf
          statements.add( cmd_while )
          return true

        endIf
      endIf

      if (consume(TokenType.KEYWORD_CALL))
        local label_name = read_label_name
        statements.add( CmdCall(t,label_name) )
        return true

      elseIf (consume(TokenType.KEYWORD_GOTO))
        statements.add( CmdGoTo(t,read_label_name) )
        return true

      elseIf (consume(TokenType.KEYWORD_HALT))
        statements.add( CmdHalt(t) )
        return true

      elseIf (consume(TokenType.KEYWORD_PRINT))
        if (next_is(TokenType.STRING))
          statements.add( CmdPrintString(t,read.text) )
          if (not consume(TokenType.SYMBOL_SEMICOLON)) must_consume( TokenType.EOL )
          return true
        else
          if (not (next_is(TokenType.EOL) or next_is(TokenType.SYMBOL_SEMICOLON)))
            local expr = parse_expression()
            if (expr.is_ch)
              statements.add( CmdPrintCh(t) )
              return true
            elseIf (expr.is_count)
              statements.add( CmdPrintCount(t) )
              return true
            elseIf (expr.is_integer)
              statements.add( CmdPrintCharacter(t,expr->Int32) )
              return true
            endIf
          endIf
          throw t.error( "Syntax error - valid 'print' arguments are  'ch', 'count', and '<string>'." )
        endIf

      elseIf (consume(TokenType.KEYWORD_SCAN_DIGITS))
        throw t.error( "Syntax error. Expected 'ch = scanDigits <min-digits>[..<max-digits>] [base <number-base>]'." )

      elseIf (consume(TokenType.KEYWORD_RETURN))
        statements.add( CmdReturn(t) )
        return true

      elseIf (next_is(TokenType.SYMBOL_LT))
        local name = read_label_name
        must_consume( TokenType.EOL )
        statements.add( CmdLabel(t,name) )
        return true

      elseIf (consume(TokenType.SYMBOL_MINUS_MINUS))
        local target = parse_register
        statements.add( CmdSubtract(t,target,CmdLiteralInt32(t,1)) )
        return true

      elseIf (consume(TokenType.SYMBOL_PLUS_PLUS))
        local target = parse_register
        statements.add( CmdAdd(t,target,CmdLiteralInt32(t,1)) )
        return true

      elseIf (consume(TokenType.KEYWORD_POP))
        statements.add( CmdPop(t) )
        return true

      elseIf (consume(TokenType.KEYWORD_PUSH))
        statements.add( CmdPush(t) )
        return true

      else
        local expr = parse_expression()

        local t2 = peek
        if (consume(TokenType.SYMBOL_PLUS_PLUS))
          statements.add( CmdAdd(t,expr,CmdLiteralInt32(t2,1)) )
        elseIf (consume(TokenType.SYMBOL_MINUS_MINUS))
          statements.add( CmdSubtract(t,expr,CmdLiteralInt32(t2,1)) )
        elseIf (consume(TokenType.SYMBOL_PLUS_EQUALS))
          statements.add( CmdAdd(t,expr,parse_expression()) )
        elseIf (consume(TokenType.SYMBOL_MINUS_EQUALS))
          statements.add( CmdSubtract(t,expr,parse_expression()) )
        else
          statements.add( expr )
        endIf
        return true

      endIf

      throw peek.error( "Syntax error - unexpected '$'." (peek->String) )

    method next_is_else_if( &single_line, &multi_line )->Logical
      consume_eols
      if (not next_is(TokenType.KEYWORD_ELSE_IF)) return false

      # Scan to just after the elseIf() conditional
      local original_pos = reader.position
      read  # elseIf
      parse_expression()

      if (single_line)
        local result = not next_is( TokenType.EOL )
        reader.position = original_pos
        return result
      else
        local result = next_is( TokenType.EOL )
        reader.position = original_pos
        return result
      endIf

    method parse_access->Cmd
      local t = peek
      local name = read_identifier
      return CmdAccess( t, name )

    method parse_register->Cmd
      local t = peek
      if (consume(TokenType.KEYWORD_CH)) return CmdRegisterCh( t )
      if (consume(TokenType.KEYWORD_COUNT)) return CmdRegisterCount( t )
      throw t.error( "Register 'ch' or 'count' expected." )

    method read_identifier->String
      if (next_is(TokenType.IDENTIFIER))
        local name = read->String
        return name
      else
        throw peek.error( "Identifier expected." )
      endIf

    method read_integer->Int32
      if (next_is(TokenType.INTEGER))
        return read->Int32
      else
        throw peek.error( "Integer value expected." )
      endIf

    method read_label_name->String
      must_consume( TokenType.SYMBOL_LT )
      local name = read->String
      must_consume( TokenType.SYMBOL_GT )
      return name

endClass
