module Froley
  uses ParseKit<<Froley>>

enum ParseRuleType
  GENERAL
  PRE_UNARY
  POST_UNARY
  BINARY
  LIST
endEnum

class CmdTypeProperty( name:String, type:String, value="":String )
  METHODS
    method to->String
      return "$=$:$" (name,value,type)

    method to->Value
      return @{ :name, :type, :value }
endClass

class CmdType( t:Token, name:String, type:ParseRuleType, index:Int32, symbol:String, properties:CmdTypeProperty[], base_type:String )
  METHODS
    method subcommand_count->Int32
      if (properties is null) return 0
      local n = 0
      if (not ((forEach in properties).value->String.begins_with("t."))) ++n
      return n

    method to->String
      return name

    method to->Value
      local property_list = @[]
      if (properties) property_list.add( (forEach in properties)->Value )
      return @{ :name, :index, :type, :symbol, properties:property_list, :base_type }

    method verify_args( args:CmdTypeProperty[] )
      contingent
        necessary (properties? == args?)
        if (properties is null) return

        forEach (b at index in args)
          local a = properties[ index ]
          necessary (a.name == b.name)
          necessary (a.type == b.type)
          necessary (a.value == b.value)
        endForEach

      unsatisfied
        local a_sig = which{ properties:"$($)"(name,properties.join(",")) || name+"()" }
        local b_sig = which{ args:"$($)"(name,args.join(",")) || name+"()" }
        throw t.error( "Inconsistent initializers used for $ ($ <> $)." (name,a_sig,b_sig) )

      endContingent

endClass

