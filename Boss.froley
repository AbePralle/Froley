#---------------------------------------------------------------------
[attributes]
#---------------------------------------------------------------------
structural

#---------------------------------------------------------------------
[keywords]
#---------------------------------------------------------------------
KEYWORD_AUGMENT     augment
KEYWORD_CLASS       class
KEYWORD_ELSE        else
KEYWORD_ELSE_IF     elseIf
KEYWORD_END_CLASS   endClass
KEYWORD_END_IF      endIf
KEYWORD_END_ROUTINE endRoutine
KEYWORD_END_WHILE   endWhile
KEYWORD_FALSE       false
KEYWORD_GLOBAL      global
KEYWORD_IF          if
KEYWORD_IMPORT      import
KEYWORD_LOCAL       local
KEYWORD_METHOD      method
KEYWORD_METHODS     METHODS
KEYWORD_NULL        null
KEYWORD_PRINTLN     println
KEYWORD_PROPERTIES  PROPERTIES
KEYWORD_RETURN      return
KEYWORD_ROUTINE     routine
KEYWORD_THIS_CALL   thisCall
KEYWORD_TRUE        true
KEYWORD_UNDEFINED   undefined
KEYWORD_WHILE       while

#---------------------------------------------------------------------
[symbols]
#---------------------------------------------------------------------
SYMBOL_AMPERSAND            &
SYMBOL_ARROW                ->
SYMBOL_ASTERISK             *
SYMBOL_AT                   @
SYMBOL_BANG                 !
SYMBOL_CARET                ^
SYMBOL_CLOSE_BRACE          }   [structural]
SYMBOL_CLOSE_BRACKET        ]   [structural]
SYMBOL_CLOSE_PAREN          )   [structural]
SYMBOL_COLON                :   [structural]
SYMBOL_COLON_COLON          ::
SYMBOL_COMMA                ,   [structural]
SYMBOL_DOLLAR               $
SYMBOL_DOUBLE_VERTICAL_BAR  ||  [structural]
SYMBOL_EQ                   ==
SYMBOL_EQUALS               =
SYMBOL_GE                   >=
SYMBOL_GT                   >
SYMBOL_GT_GT                >>
SYMBOL_LE                   <=
SYMBOL_LEFT_SHIFT           :<<:
SYMBOL_LITERAL_OPEN_BRACKET @[
SYMBOL_LT                   <
SYMBOL_LT_LT                <<
SYMBOL_MINUS                -
SYMBOL_MINUS_MINUS          --
SYMBOL_NE                   !=
SYMBOL_OPEN_BRACE           {
SYMBOL_OPEN_BRACKET         [
SYMBOL_OPEN_PAREN           (
SYMBOL_PERCENT              %
SYMBOL_PERIOD               .
SYMBOL_PLUS                 +
SYMBOL_PLUS_PLUS            ++
SYMBOL_QUESTION             ?
SYMBOL_QUESTION_COLON       ?:
SYMBOL_RIGHT_SHIFT          :>>:
SYMBOL_RIGHT_SHIFT_X        :>>>:
SYMBOL_SEMICOLON            ;
SYMBOL_SLASH                /
SYMBOL_TILDE                ~
SYMBOL_VERTICAL_BAR         |

#---------------------------------------------------------------------
[tokenizer]
#---------------------------------------------------------------------
<<tokenize>>
while (hasAnother)
  ch = peek
  if (ch != 32)
    if (ch != '\t') goto whitespace_consumed
  endIf
  ch = read
endWhile

<whitespace_consumed>
markSourcePosition
if (not hasAnother) halt


<tokenize_identifier>
if (scanIdentifier)
  which (buffer)
    acceptAll [keywords]
    others: accept IDENTIFIER
  endWhich
endIf

<tokenize_numbers>
which (input)
  case "0b"
    count = 2
    clear buffer
    scan_integer
    accept BINARY_INTEGER
  case "0c"
    count = 8
    clear buffer
    scan_integer
    accept OCTAL_INTEGER
  case "0x"
    count = 16
    clear buffer
    scan_integer
    accept HEX_INTEGER
  others
    ch = peek
    if (ch is digit)
      count = 10
      scan_integer
      accept INTEGER
    endIf
endWhich

<tokenize_symbols>
which (input)
  acceptAll [symbols]
  case '\n': accept EOL
  case '#'
    ch = read
    while (ch != '\n') ch = read
    discard
  case '"'
    goto scan_string
  case "''"
    goto scan_double_single_quote_string
  case '\''
    clear buffer
    scan_character
    consume('\'')
    accept CHARACTER
endWhich


print "Syntax error\n"
print "got: "
print ch
print "\n"

halt

<scan_identifier>
while (ch is letter or ch is digit or ch == '_')
  ch = read
  collect ch
  if (not hasAnother) return
  ch = peek
endWhile
return

<scan_integer>
while (ch is digit(count) or ch == '_')
  ch = read
  if (ch != '_') collect ch
  if (not hasAnother) return
  ch = peek
endWhile
return


<scan_string>
clear buffer
ch = read
while (ch != '"')
  collect ch
  ch = read
endWhile
accept STRING

<scan_double_single_quote_string>
clear buffer
while (hasAnother)
  ch = read
  if (ch == '\'')
    ch = peek
    if (ch == '\'')
      ch = read
      accept STRING
    else
      collect '\''
    endIf
  else
    collect ch
  endIf
endWhile
accept STRING

<scan_character>
ch = read
if (ch == '\\')
  ch = read
endIf
collect ch
return

#---------------------------------------------------------------------
[parser]
#---------------------------------------------------------------------
